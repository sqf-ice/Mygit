inet_addr函数处理IP地址需要注意的问题2007-01-26 12:01现在我们很幸运，因为我们有很多的函数来方便地操作 IP 地址。没有 必要用手工计算它们，也没有必要用"<<"操作来储存成长整字型。 

首先，假设你已经有了一个sockaddr_in结构体ina，你有一个IP地址"132.241.5.10" 要储存在其中，你就要用到函数inet_addr(),将IP地址从 点数格式转换成无符号长整型。使用方法如下：
ina.sin_addr.s_addr = inet_addr("132.241.5.10");
注意，inet_addr()返回的地址已经是网络字节格式，所以你无需再调用 函数htonl()。
我们现在发现上面的代码片断不是十分完整的，因为它没有错误检查。 显而易见，当inet_addr()发生错误时返回-1。记住这些二进制数字？(无符 号数)-1仅仅和IP地址255.255.255.255相符合！这可是广播地址！大错特 错！记住要先进行错误检查。
好了，现在你可以将IP地址转换成长整型了。有没有其相反的方法呢？ 它可以将一个in_addr结构体输出成点数格式？这样的话，你就要用到函数 inet_ntoa()("ntoa"的含义是"network to ascii")，就像这样： 
printf("%s",inet_ntoa(ina.sin_addr));
它将输出IP地址。需要注意的是inet_ntoa()将结构体in-addr作为一 个参数，不是长整形。同样需要注意的是它返回的是一个指向一个字符的 指针。它是一个由inet_ntoa()控制的静态的固定的指针，所以每次调用 inet_ntoa()，它就将覆盖上次调用时所得的IP地址。例如：
char *a1, *a2;
.
.
a1 = inet_ntoa(ina1.sin_addr); /* 这是198.92.129.1 */
a2 = inet_ntoa(ina2.sin_addr); /* 这是132.241.5.10 */
printf("address 1: %s ",a1);
printf("address 2: %s ",a2);
输出如下：
address 1: 132.241.5.10
address 2: 132.241.5.10
假如你需要保存这个IP地址，使用strcopy()函数来指向你自己的字符指针。

-----------
在Linux和Windows网络编程时需要用到htons和htonl函数，用来将主机字节顺序转换为网络字节顺序。

     在Intel机器下，执行以下程序

  

int main(void)
...{
   printf("%d \n",htons(16));
}
得到的结果是4096，初一看感觉很怪。

    解释如下，数字16的16进制表示为0x0010，数字4096的16进制表示为0x1000。 由于Intel机器是小尾端，存储数字16时实际顺序为1000，存储4096时实际顺序为0010。因此在发送网络包时为了报文中数据为0010，需要经过htons进行字节转换。如果用IBM等大尾端机器，则没有这种字节顺序转换，但为了程序的可移植性，也最好用这个函数。

   另外用注意，数字所占位数小于或等于一个字节（8 bits）时，不要用htons转换。这是因为对于主机来说，大小尾端的最小单位为字节(byte)。


 
