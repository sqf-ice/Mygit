/************************************************************************
*
* copyright(c)2005-2008 Newland Co. Ltd. All rights reserved
* module			: 算法模块
* file name		: alg6.c
* Author 			: wangzy
* version			:
* DATE				: 20130319
* directory 	:
* description	: 测试NDK_AlgRSARecover接口功能
* related document	: NDK.chm
*
************************************************************************
* log			:
* Revision
* no message(created for ARM250 platform)
************************************************************************/
/*-----------------------includes-------------------------------*/
#include "mode.h"

/*---------------constants/macro definition---------------------*/
#define 	TESTAPI		"NDK_AlgRSARecover"
//#define     RSA_EXP_NUM  2

/*------------global variables definition-----------------------*/

/*----------global variables declaration("extern")--------------*/

/*---------------structure definition---------------------------*/

/*---------------functions declaration--------------------------*/

/*---------------functions definition---------------------------*/
/****************************************************************
* function name 	 	:
* functional description 	:
* input parameter	 	:
* output parameter	 	:
* return value		 	:
* history 		 		: author			date			remarks
*			  	  	     wangzy         20130319  	   created
*****************************************************************/
void alg6(void)
{
	//局部变量初始化
#if !K21_ENABLE	
	//公钥指数为03生成的公私密钥对
	//512、1024、2048位的模
	uchar module512[129]="9E180D80AF72B01EEC7A1A32266730174F2B318ECDBAA28F9A1B739C06A7E2FF0463417E5583FA8A608D0CADD4BCD58F94F8046CF298A1A9FB2E34F556F28539";
	uchar module1024[257]="865D56B82A5CC6B0229E91E70B0DCCEB795E8124EADAB9DF77C06BA2E32898A190B0CBFAF3A0C1123B4B864771F53BEC3D1334742F6359A5F6BAF9B07FEEADCA96A6862538D8FA6138A862554383F60C36E72BFE2358EB26FB22026BA5279433D09F65FA4BE6D66283B87DF55C65CBDEA9222C2A9D460CB055791584A161B741";
	uchar module2048[513]="967CBB590B15A632F57515DAFC40B5B07EB22736A35BF557FC51F69DF0DF5357F7432E2E656D4A869DF4F3C50F5CA8A56439628044465C6AACD4CBB11A568D433D8E2959EE149103BA36DDE483B7B55112764D8F7C500FB73476277CC9B8038ACA558763B785C15DDC0C875E7BA8CB3A2581CC136425187B5DD6CBD90A0622D317A7D6FAAB8214956C9765996C7130D522800FDFB133474B4429E38686BDA69D6CD0908A0B0666D2C527C2E7EF7BB5DACC425D536343993CA40388955EF9001BCC11DF06C06749343F693F8FEF3458CD2168DCB773BF11DD2AA6F8E28B369E020513A49AA9A7C4C4E173663DEC7096439B75FC3ADA8A3C68A08915E78A5A4CF9";
	//512、1024、2048位数据的私钥指数
	uchar priexp512[129]="69655E55CA4C7569F2FC1176C444CABA34C7765F33D1C1B51167A268046FECA8F6AF924BD9B82F9C83326E23E2A084969B0DE6D8B026472B7A1CDCD9EAD5B6C3";
	uchar priexp1024[257]="59938F2571932F2017146144B2093347A63F00C3473C7BEA4FD59D17421B106BB5CB32A74D15D60C2787AEDA4BF8D29D7E0CCDA2CA423BC3F9D1FBCAFFF473DB6A426E946EFD9AB205A6C90AD3031F4BA23C517863B19B25EF40A3CF9C228CEDE020495504C5971F5C980023CE5F0954D97616C9A62D9F0D96D670A5CEB442E3";
	uchar priexp2048[513]="64532790B20E6ECCA3A363E752D5CE75A9CC1A246CE7F8E552E14F13F5EA378FFA2CC974439E31AF13F8A2835F931B18ED7B97002D843D9C733887CB66E45E2CD3B41B9149630B57D179E943027A78E0B6F9890A52E00A7A22F96FA8867AAD07318E5A427A592B93E8085A3EFD1B3226C3ABDD6242C365A793E487E606AEC1E107E678B5384C611B8BD334A32101F790566FF4F7AE324C048428A9A227540FDE42FC40ECBC4542F8531737A6F5291B2350144DFA57175F1646006A2C74B6602F2D37925F6171C56F2699D818F186E1AF8EBF6E802C90F6E750AD364CBB3A8D5FC7FCBAD63B2FA3225B06C854642C0954A5488F25D0B5DD04A9EA3897321E61C3";
	//工具计算的512、1024位数据输出
	uchar tools_result512[129]="77D6EAA4861984D0EDCB4ED50E4F90DED36D6635626138F66DEF837B3435680B338B0156044B7B98EC256529CD5F024818026089A592EF6507C13F5E393DA25D";
	uchar tools_result1024[257]="17FCC8619B776073D9B793A8D3481D69872FB93FA1D48BD29C0888EC6D8A15D038EB347EE87023662AF2B8656348AA9857FEED9804879C15EE14FD68F93F6610F11F31EBEE90D26A5E2693402DD5A3274C5618AB38D762DA135CBD329B4EFE76F1726130849A55EB0A85E24C16A65463FE161C0317E85681C863B18300E63D6E";
	//uchar tools_result2048[513]="30675FD12704FC160DB6BBAE58DA17978204936B45775E709FD8E28205C4249FC2AFA9157E85CD626D774B31FC4B507580A35D7F9347EC38F86D863397E85737C710360D0A3B150626B9AED0C8F832844F9ED5265BC8EF7D1546E2CC7B071C50EE3D4F808C2E8432344B483655B29FBF2E8F9BFBA36799912978E32F9E58F3B65BB7B9D2A43A85EB874103B281929A74A3A4E6D5B1494ABBDCAE72E709732FCBD8A175BD92F5BD66FD5C5CCAEA75FB8F9BCD9FDE380D75A3565B28CA1A7AA9BC214629DFE59928BB9F5183AEBDB87BF168BA753D6AFE8029BB8B8DA12AEE04A813D07AFF94F9971850B3B56F15723C1C2060A16F0026798AA1AB2E8668653230";
#endif
	//公钥指数为10001生成的公私密钥对
	//1024、2048位的模	
	uchar module1024_10001[257]="C0929407549DAAA509EB7F56C8B57C8EC9E08E84ACC611E7023516067A44467A039A1B3C2FCD7BAE2CFA640C17AE770A4C12F1B21697FCFE4287E7C4EA2D23C3DDEE57B24A794A91CDBD0897A5D770A5B4BCE4234A7CC757E45FA3037E170B2CF135DD4A1F086431D11A37C46003CEDA02B38479BF05AA45B17A13A6D77BFC69";
	uchar module2048_10001[513]="C39ECB31F79CECE625C988E9103AA0B27CF1EAAA813ADE578FAC1DD286B22F4705B3D04DF9CB3A9C6B9ABB4AC4BC346BACCC82DEFF320475CF3E0287873DFAA80E3C286DB1B79271AE97F9049ECC3BAB6440AF70C23DA501DE8C493158603EB99CB8D76571C4E334949D5BB7D8781E8ECA2BE06AA6C2FC45461CBDF9BF87E77866CD14FD940328B015E2930EFC1D5898D78E80440ACC57ECE4EEC6CE569D434834381FB15B29F2460230854FB122A4831F8B2531E395AC443840615FD189DB2459E15DC859CA438E9DB0FDAE25B7CFFD65093F1977CBE016CE23033104F3669A3629D9BC9DD5D475B4370123D191CEDF6F36D07C51C08A69307DBCAC8E1A7F89";
	//1024、2048位数据的私钥指数
	uchar priexp1024_10001[257]="A6C3C8F1783379BDA6938C18E98351348E5AAAD0F6962896B6F0A5FC4211B23EA3B3E6F5FE27A27DB971B5064BD3C83EE0965F3C6C187EFCE93CAC5778BC528520D9BB14CBB6E8DA2AEA370AABDB6AA448E4929F187CF4E04AB9DB85FD05E315947A5DAC7BAF6C1F39D0D8F5ED012535B53175CDC57C157362E45D028937A3C9";
	uchar priexp2048_10001[513]="C28F870D7577106F7F19C91FF4D23ACE0B5318D0E8A3424CD84A9986B00D3CD468A984FE68F9669BF8B1F6A1D0B65774D872B79F4F35D215D23F9C886B4C8BA6E631930C36FB9B9D91C6F9174D5157EF895084ADA3A3682049D6415DE0C628DCB731689A2EE3620F03D8D6462DF89A7BEE3C6181F1C670DDFD73CCC73F65CE22C3ACA21F061754C91C5B3796FC8C9D16A0603FBBACDF00ED4B102DC11C5E122DA4D0D92495F23B67B6D6611C1C293A654A2A281BED4F2BA8002643C8133565BDEC93CFCC2707A1143A39829E797EB8B7577ABA719096D1DD890374B921F813FF1B56DF8D7798D7835EDB0E77EC1DB9106C1750B73F7B88060B3537C13B0399F9";
	//公钥指数
	uchar pubexp[3]="03";	
	uchar pubexp_10001[6]="10001";
	//工具计算的512、1024位数据输出
	uchar tools_result1024_10001[257]="2E7B8384541414C82669E52DD963DFEEDB456D7CA9BA5A9603AF45B60189E1DB3B08FB527EA406AE89814DE5C51B4DDE292EA84D10087656DAA2B313FCA6D409C03B4F5BEFCA1139009A21EF250FA3D5E8E61806847CB8DA11A1D79D038B228F5672C2CE3621C36F637BC28EBE0F4AB19C0A143701051B8E83A4EAB48CE7AA29";	
	//512、1024、2048位的输入数据
	uchar  datain512[65]="THISISATESTTHISISATESTTHISISATESTTHISISATESISATESTTHISISATESTTTT";
	uchar  datain1024[129]="THISISATESTTHISISATESTTHISISATESTTHISISATESISATESTTHISISATESTTTTTHISISATESTTHISISATESTTHISISATESTTHISISATESISATESTTHISISATESTTTT";
	uchar datain2048[257]="ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ";
	//512、1024、2048位的输出数据
	uchar  dataout512enc[65]={0},dataout512dec[65]={0},dataout1024enc[129]={0},dataout1024dec[129]={0},dataout2048enc[257]={0},dataout2048dec[257]={0};
	//用于字符串装换的输出
	uchar dataouthex[513]={0};
	int ret=0;

	cls_printf("测试%s...", TESTAPI);
	//case1: 非法参数测试
	if((ret = NDK_AlgRSARecover(NULL,RSA_KEY_LEN_1024/8,pubexp_10001,datain1024,dataout1024enc)) !=NDK_ERR_PARA)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if((ret = NDK_AlgRSARecover(module1024_10001,(RSA_KEY_LEN_1024/8-1),pubexp_10001,datain1024,dataout1024enc)) !=NDK_ERR_PARA)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if((ret = NDK_AlgRSARecover(module2048_10001,(RSA_KEY_LEN_2048/8+1),pubexp_10001,datain2048,dataout2048enc)) !=NDK_ERR_PARA)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if((ret = NDK_AlgRSARecover(module1024_10001,(RSA_KEY_LEN_1024)/8,NULL,datain1024,dataout1024enc)) !=NDK_ERR_PARA)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if((ret = NDK_AlgRSARecover(module1024_10001,(RSA_KEY_LEN_1024)/8,pubexp_10001,NULL,dataout1024enc)) !=NDK_ERR_PARA)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if((ret = NDK_AlgRSARecover(module1024_10001,(RSA_KEY_LEN_1024)/8,pubexp_10001,datain1024,NULL) )!=NDK_ERR_PARA)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret); 
		RETURN;  
	}
#if K21_ENABLE//低端上公钥指数不能传“03”
	if((ret = NDK_AlgRSARecover(module1024_10001,(RSA_KEY_LEN_1024)/8, pubexp, datain1024,dataout1024enc) )!=NDK_ERR_PARA)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret); 
		RETURN;  
	}
#endif
	//case2:正常测试:03指数下各种支持的密钥长度测试
#if !K21_ENABLE//中端平台支持RSA_KEY_LEN_512和RSA_EXP_3 
	//case2.1:512位数据的处理,03指数测试
	if((ret = NDK_AlgRSARecover(module512,RSA_KEY_LEN_512/8,pubexp,datain512,dataout512enc)) !=NDK_OK) 
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	NDK_HexToAsc(dataout512enc,128,1,dataouthex);
	if(memcmp(tools_result512,dataouthex,strlen((char *)tools_result512)))
	{
		send_result("line %d:%s测试失败", __LINE__, TESTAPI);
		RETURN;
	}
	if((ret = NDK_AlgRSARecover(module512,RSA_KEY_LEN_512/8,priexp512,dataout512enc,dataout512dec)) !=NDK_OK)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if(memcmp(datain512,dataout512dec,strlen((char *)datain512)))
	{
		send_result("line %d:%s测试失败", __LINE__, TESTAPI);
		RETURN;
	}

	memset(dataouthex,0,sizeof(dataouthex));
	//case2.2:1024位数据的处理,03指数测试
	if((ret = NDK_AlgRSARecover(module1024,RSA_KEY_LEN_1024/8,pubexp,datain1024,dataout1024enc)) !=NDK_OK)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	NDK_HexToAsc(dataout1024enc,256,1,dataouthex);
	if(memcmp(tools_result1024,dataouthex,strlen((char *)tools_result1024)))
	{
		send_result("line %d:%s测试失败", __LINE__, TESTAPI);
		RETURN;
	}
	if((ret = NDK_AlgRSARecover(module1024,RSA_KEY_LEN_1024/8,priexp1024,dataout1024enc,dataout1024dec)) !=NDK_OK)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if(memcmp(datain1024,dataout1024dec,strlen((char *)datain1024)))
	{
		send_result("line %d:%s测试失败", __LINE__, TESTAPI);
		RETURN;
	}

	memset(dataouthex,0,sizeof(dataouthex));
	//case2.3:2048位数据的处理,03指数测试
	if((ret = NDK_AlgRSARecover(module2048,RSA_KEY_LEN_2048/8,pubexp,datain2048,dataout2048enc)) !=NDK_OK)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if((ret = NDK_AlgRSARecover(module2048,RSA_KEY_LEN_2048/8,priexp2048,dataout2048enc,dataout2048dec)) !=NDK_OK)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if(memcmp(datain2048,dataout2048dec,strlen((char *)datain2048)))
	{
		send_result("line %d:%s测试失败", __LINE__, TESTAPI);
		RETURN;
	}
#endif

	//case3:指数10001下的数据处理
	//case3.1:1024位数据的处理
	memset(dataouthex,0,sizeof(dataouthex));
	if((ret = NDK_AlgRSARecover(module1024_10001,RSA_KEY_LEN_1024/8,pubexp_10001,datain1024,dataout1024enc)) !=NDK_OK)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	NDK_HexToAsc(dataout1024enc,256,1,dataouthex);
	if(memcmp(tools_result1024_10001,dataouthex,strlen((char *)tools_result1024_10001)))
	{
		send_result("line %d:%s测试失败", __LINE__, TESTAPI);
		RETURN;
	}
	if((ret = NDK_AlgRSARecover(module1024_10001,RSA_KEY_LEN_1024/8,priexp1024_10001,dataout1024enc,dataout1024dec)) !=NDK_OK)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if(memcmp(datain1024,dataout1024dec,strlen((char *)datain1024)))
	{
		send_result("line %d:%s测试失败", __LINE__, TESTAPI);
		RETURN;
	}
	//case3.1:2048位数据的处理
	memset(dataouthex,0,sizeof(dataouthex));	
	if((ret = NDK_AlgRSARecover(module2048_10001,RSA_KEY_LEN_2048/8,pubexp_10001,datain2048,dataout2048enc)) !=NDK_OK)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if((ret = NDK_AlgRSARecover(module2048_10001,RSA_KEY_LEN_2048/8,priexp2048_10001,dataout2048enc,dataout2048dec)) !=NDK_OK)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if(memcmp(datain2048,dataout2048dec,strlen((char *)datain2048)))
	{
		send_result("line %d:%s测试失败", __LINE__, TESTAPI);
		RETURN;
	}

	//case4: 异常测试:边缘值测试psDataIn的值大于模的值,应返回参数错误
	datain1024[0]=0xC1;
	if((ret = NDK_AlgRSARecover(module1024_10001,RSA_KEY_LEN_1024/8,pubexp_10001,datain1024,dataout1024enc) )!=NDK_ERR_PARA)
	{	
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	
	//测试结束
	send_result("%s测试通过", TESTAPI); 	
	return;
}

