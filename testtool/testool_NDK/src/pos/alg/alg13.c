/************************************************************************
*
* copyright(c)2005-2015 Newland Co. Ltd. All rights reserved
* module			: 算法模块
* file name		    : alg13.c
* Author 			: zhengry	
* version			:
* DATE				: 20150908
* directory 		:
* description		: 测试NDK_AlgSM2Verify函数使用SM2非对称公私钥对中的公钥对数字签名（64字节）计算摘要（32字节）的功能（国密算法）
* related document	: NDK.chm
*
************************************************************************
* log			:
* Revision
* no message(created for ARM250 platform)
************************************************************************/
/*-----------------------includes-------------------------------*/
#include "mode.h"

/*---------------constants/macro definition---------------------*/
#define 	TESTAPI		"NDK_AlgSM2Verify"

/*------------global variables definition-----------------------*/

/*----------global variables declaration("extern")--------------*/

/*---------------structure definition---------------------------*/

/*---------------functions declaration--------------------------*/

/*---------------functions definition---------------------------*/
/****************************************************************
* function name 	 	:
* functional description 	:
* input parameter	 	:
* output parameter	 	:
* return value		 	:
* history 		 		: author			date			remarks
*			  	  	      zhengry           20150908  	    created
*****************************************************************/
void alg13(void)
{
	int ret=0;
	uchar prikey[32]={0}, pubkey[64]={0}, summary[32]={0}, sign_data[65]={0}, message[]="newland";
	uchar ID[]={"test"};
	uchar pre_pubkey[64]={0x8c,0xc2,0x4d,0x59,0x18,0x02,0x26,0x31,0x14,0x5a,0x1f,0x3f,0x23,0x90,0x99,0xda,
						  0x14,0x06,0xea,0x26,0xb9,0x76,0x11,0xb3,0x09,0x2f,0xbb,0x1c,0x6d,0x7a,0xf1,0xde,
						  0xb0,0x55,0x95,0x29,0x82,0x38,0x21,0x0c,0x28,0xa2,0x82,0xbd,0x41,0x5a,0x27,0x78,
						  0x7e,0xf5,0xaf,0xc8,0x8d,0x7e,0xe2,0x99,0x16,0xc6,0x3d,0x52,0x12,0xa3,0x31,0x09};
	uchar pre_summary[32]={0x2B,0xEC,0x3D,0x7D,0x6D,0x54,0x8A,0x48,0x29,0xB5,0x98,0x41,0xE4,0xE7,0xFF,0xD4,
					 	   0xE8,0x07,0x7F,0x55,0x0D,0x9C,0x69,0x49,0x18,0xD1,0x69,0xC4,0x40,0xF6,0x53,0x3F};
	uchar pre_signdata[64]={0x22,0x92,0xC5,0x29,0xC4,0x99,0x60,0x13,0xE3,0xD2,0x91,0x7F,0x69,0x1E,0x41,0x44,
							0xEB,0xC7,0x4E,0xAD,0xC3,0x38,0xE5,0x6B,0x1B,0x68,0x8A,0x6A,0xFC,0x9B,0x9C,0x15,
							0xAC,0xF0,0x12,0xFC,0xEB,0xF4,0x2B,0x6A,0x4B,0x5E,0xAB,0x53,0x12,0x01,0x75,0x9E,
							0xA9,0x36,0xEC,0xBC,0x21,0xD5,0xFF,0xCD,0xC2,0x45,0xD6,0xBF,0x13,0x43,0x41,0x16};//开发提供的数据
	uchar err_signdata[64]={0x22,0x92,0xC5,0x29,0xC4,0x99,0x60,0x13,0xE3,0xD2,0x91,0x7F,0x69,0x1E,0x41,0x44,
							0xEB,0xC7,0x4E,0xAD,0xC3,0x38,0xE5,0x6B,0x1B,0x68,0x8A,0x6A,0xFC,0x9B,0x9C,0x15,
							0xAC,0xF0,0x12,0xFC,0xEB,0xF4,0x2B,0x6A,0x4B,0x5E,0xAB,0x53,0x12,0x01,0x75,0x9E,
							0xA9,0x36,0xEC,0xBC,0x21,0xD5,0xFF,0xCD,0xC2,0x45,0xD6,0xBF,0x13,0x43,0x41,0x17};//在pre_signdata基础上修改最后一个
	uchar pre_pubkey1[64]={0x97, 0xbc, 0x43, 0x9c, 0x57, 0xe1, 0xd6, 0x2e,0x4d, 0xb8, 0x1b, 0x70, 0x72, 0x6a, 0xdb, 0x5f,
						   0xf7, 0xc7, 0x3a, 0xe3, 0xb6, 0xcb, 0xc5, 0x9b,0xad, 0xb8, 0x2d, 0x65, 0xf7, 0x5e, 0xd6, 0xc1,
						   0x9d, 0xf6, 0xcb, 0xe6, 0x31, 0x21, 0x3a, 0xe6,0x21, 0x24, 0xe7, 0xd7, 0xb2, 0x92, 0x19, 0x69,
						   0x20, 0x2c, 0x64, 0xd1, 0x11, 0xce, 0xa5, 0x1c,0x83, 0x08, 0x54, 0x58, 0xa2, 0x8e, 0xcc, 0x19};
	uchar pre_summary1[32]={0x62,0xAB,0xD6,0x22,0x5F,0x32,0xA4,0xB4,0xE8,0x19,0x9D,0x3B,0x61,0x0A,0x10,0x45,
							0x8A,0xE1,0xA0,0xD6,0x58,0x0E,0x86,0xD0,0xFB,0xB0,0xD8,0xB7,0x0D,0xED,0x78,0x92};
	uchar pre_signdata1[64]={0x59,0x52,0x5D,0xCE,0xB6,0x77,0x7A,0x80,0xA2,0x36,0x96,0x78,0xE5,0x40,0x51,0xB5,
							 0x8E,0xA1,0x70,0x2F,0x0D,0xAB,0x02,0xF2,0xFE,0x47,0xF9,0x5D,0xC9,0x92,0xC1,0x68,
							 0x6A,0x3F,0x6F,0xE5,0x26,0xB6,0x6C,0x5C,0xB2,0xEB,0x18,0xE1,0x89,0xEF,0x97,0xD5,
							 0x62,0x66,0x1D,0xF7,0xF8,0x66,0xBA,0x73,0x3E,0xE3,0x6D,0xC9,0x85,0x05,0x6F,0x04};//大数据(alg11下3668字节数据)

	//process body
	cls_printf("测试%s...", TESTAPI);

	//测试前置
	memset(prikey, 0, sizeof(prikey));
	memset(pubkey, 0, sizeof(pubkey));
	memset(summary, 0, sizeof(summary));
	memset(sign_data, 0, sizeof(sign_data));
	if((ret=NDK_AlgSM2KeyPairGen(pubkey, prikey))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if((ret=NDK_AlgSM2GenE(strlen((char *)ID), ID, strlen((char *)message), message, pubkey, summary))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if((ret=NDK_AlgSM2Sign(prikey, summary, sign_data))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}

	//case1:参数异常 
	if((ret=NDK_AlgSM2Verify(NULL, summary, sign_data))!=NDK_ERR_PARA)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if((ret=NDK_AlgSM2Verify(pubkey, NULL, sign_data))!=NDK_ERR_PARA)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	if((ret=NDK_AlgSM2Verify(pubkey, summary, NULL))!=NDK_ERR_PARA)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}

	//case2:正常测试
	if((ret=NDK_AlgSM2Verify(pubkey, summary, sign_data))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	
	//case3: 异常测试:错误的公钥，则验签失败
	if((ret=NDK_AlgSM2Verify(pre_pubkey, summary, sign_data))!=NDK_ERR)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}

	//case4:异常测试:摘要错误，摘要跟签名值不匹配，则验签失败
	if((ret=NDK_AlgSM2Verify(pubkey, pre_summary, sign_data))!=NDK_ERR)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	
	//case5:异常测试:签名错误，摘要跟签名值不匹配，则验签失败
	if((ret=NDK_AlgSM2Verify(pre_pubkey, pre_summary, err_signdata))!=NDK_ERR)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}
	
	//case6:正常测试:预设公钥和生成的摘要和签名，则验签应该成功 
	if((ret=NDK_AlgSM2Verify(pre_pubkey, pre_summary, pre_signdata))!=NDK_OK) 
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}

	//case7:大数据测试
	if((ret=NDK_AlgSM2Verify(pre_pubkey1, pre_summary1, pre_signdata1))!=NDK_OK) 
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		RETURN;
	}

	//测试结束
	send_result("%s测试通过", TESTAPI); 	
	return;
}

