/************************************************************************
*
* copyright(c)2012-20xx Newland Co. Ltd. All rights reserved
* module		: 安全模块
* file name	: sec6.c
* Author 		: linrq
* version		: 
* DATE			: 20130228
* directory 		: 
* description		: 测试NDK_SecRecover接口功能
* related document	: NDKapi.chm
*
************************************************************************
* log			: 
* Revision 
* no message(created for ARM250 platform)
************************************************************************/
/*-----------------------includes-------------------------------*/
#include "mode.h"

/*---------------constants/macro definition---------------------*/
#define TESTAPI	"NDK_SecRecover"	

/*------------global variables definition-----------------------*/

/*----------global variables declaration("extern")--------------*/

/*---------------structure definition---------------------------*/

/*---------------functions declaration--------------------------*/

/*---------------functions definition---------------------------*/

/****************************************************************
* function name 	 	: 
* functional description 	:
* input parameter	 	:无
* output parameter	 	:无
* return value		 	:无
* history 		 		:  author		date		remarks
*			  	  	   linrq       20130228	created
*****************************************************************/
/*uModulus1:对应512,sExponent=3, ID=1的公钥p="B72FD439F57098124A39036114A5106BF2F26DC232EFA1379F46FBECC32D8ED3", 
						q="F085020736C3861F3D599E8B9F38C5E01BDA44411A87CD1F196DCE9B1A20B1B3"
						e="72BD582CC0E8E27E02B3B89113D03EEAB324A2F680DBB57C4A07DF80152BCF1AABAD1F72B94CF53AAA663B9D9A5B0A76C98812B5119B284BAD40E5F242730003"*/
						
/*uModulus2, uExponent2:对应1024,ID=2的私钥,sExponent=0x10001  P="9C761D3BEEF315C45AD10DB4648D315BA8532D3DFC0B724CA7486456159054FA126967D92B4B36D0D0BF1CE3425901DCB61CC8D6CC1AA86CE125FAE486830BEB"
						Q="B67F0982E2BD420051598358DEECA10033F1D387515C455AE663071ABB7F33B6587406DE8614C3E27C9C88AB8533F6D0EA3EDE846278C4D50F423CEBD66876EB""*/
						
/*uModulus3,uExponent3 ID=3和ID=4: bit=2048.公钥sExponent=0x10001  
				P="DF912D8A098DDE869E191F2D3BDE07BE9F0240C1F68890689EDF343FD2642177620132CD23BF0A58E52C501C64B0B25B021DC35DF4D33B2B49541883112F3E50E8220E58CBEE75D78C01859E81EAE36EBBD4D30E5AD7AB7414C073141A31E7491BB27C345B128D6134BECF9F137B50A99C8F5B40AF7EF1F1FE5A4339952EBDE3"
				Q="A709CC70BD8830DD7298F04192899E43D88AF3FF9655AB851CD288C03AA51976F9BADEDADAEB2E294DD8CB45E736123B9433CDDA9920C23C4E4512FEC75F7BBC60B8E93A5527479A56E068C56BC18534813664A890EB41B78AAECEF8E32CB88AFCEE743E8E88646CC8DDEC530292B34ECBA181E92C938F2B1B41CC9E1343AA93"*/
				
/*uModulus4: usBits=4096,sModulus由工具生成,sExponent=0x10001
				P="F850440DCBDD8EC0B1CD8DCBB3A98EA2561581EF8E702FEF766007B3BE6D82DA96BFFBFEA0C849EB464D2A38115BFE9FF6D64F9F751C4C041D90ADEF5738E85E1A7C1EC9791FCAFACC77CC6826027C0C8584B628DF4994303EFB52585D4F34A0DD09F588E1F6B09D8F83F28FEDCD135D96A69B99B683CB8C2DDDD26D0CB0DB97C18F9C274DDC581B7A20041C54D8EF999BDABFB3D0CBDB616932E93DABEE5FE441E3A768C2C971B97FBD426B75B09D92F60E951572335D21FD9F48D1572EA533C4651DEE7735EFA213AEB26B9C9DD6E0020EEA76977E93E45E6FDCCDFF36989831968B67EB4471ADD3424673AA31479AFC34912119467B53767434272A626923"
				Q="B8FCBE2381B8ECECB8BCC3373565542D277BBA1A01AECDE7692C07399DB8B79AC8C75BCA8956C932964A119026FA854ADAEF7DEFD0C721671ECABEBC55E933C8DF63F4E661E11C8641392BBCC08D07839ACFDEA4A85AF4E03E906182CEB247966C0457F29750CE3BA64F4665FC3D0885913838F55F0CF959B025973AA966B9084ACCB4F717F6C753A73A7F974E3B47D3C5CE3898C1E8989B32B2290CAC0FD193959EC5AA2A849D41ED4D0A528B3F547438F01D12570E3393CC928B3531A1B64A5AEA4C8750A39ACE3C6B961FB70058AD678066595B3336114F703AAB3672D681A2C3CA4974B8223E5457EDCF13A90C42C14E9A1A787274DF0B39675C9F9FD6AB"
				E="32598A5088FB042457088C3BBDFE3D3BC51ADCFE17C186F47DB62CFDBFB6A0375AC0567ADC37E4482AF3C45B84AF8D1E5B2B1821C9860B54F904C43A59CD31E9F4956EF4D1F2C3B4EA70C01E1A920B2A214086BD133D2E5DD16EA89AD0672220F6F243DC73FBE53CB418E825F1B0BD734121B0C791A4107A080A5761ED99D7702204A1E7E763711B7ADA885228592A49825BC056173AE785A7C58870F4AC634D6DA119B2DB16EAB8EA3DAA71199B34865C1666DB7596AFBC51AEDE6B722B64F426E9874B0B51A93A677A80D50289D50605C76DCBBB80C4A2FA43F77C5DFBBCFABCE7D56FC3186CBDF125A9BAD8EB416154AEB7EE30F618C994192413EBA98A41241E3FBEAB9A09CE1883D31E313C453F6D4D11AE432DB078E81A1A19325F177B1B891177DD8633DA96C44CCBCEB78041EF76AA99F537F72BAF84CC4B60820F09A006244BCFDAFF21E08684927F1AB707B57A9266652E4C834632302F3E77BF6B570B23B9ADF15D985057FAF572D70EA8557FE75CC6000B0C066BC21FEEC6462345452DEEC2CC444E8DCDA23F5710DC83C6321753C8A3E8CC214F65E649FDB8F411FC997144CA31A1AEDD1B58731561D00C76818482AB42E45DDAA5C7C68B535F0E44C47618F186DD029EA1B187DCBA5A199BC2CC4EC35AB0F8C81BEB81C41707D26524D0A2BAE65CBA05245C70D3C47F4E8AD0165A358E50114FBBAE0482AFB9"*/

void sec16(void)
{
	int ret = -1/*,i*/;
	ST_SEC_RSA_KEY RsaKeyIn;
	uchar *uModulus1=(uchar *)"AC1C0443215D53BD040D94D99DB85E600CB6F471C149903A6F0BCF401FC1B6A9A938856D42278E09872BFB591B6665FE3D18CE12E7E02AC83C96237340FAC089";
	uchar *uModulus2=(uchar *)"6F899D31423241406BA22D3B7B9E8B0A7F5A192871C1C4B9832DF86741E16A4F5DCB1C4442E53CA0C148055DE367A5CCFFF5C83B1291ED8AF919EBC20D0D3FFCC0FC19C602EF58074153B55A43154A78B1B662952770B6F349CD4EAA7E2B40E300AFB2CF32EFCB72E730C878B1D95BC13035D7608A5414342D77DBB42B4242B9";
	uchar *uExponent2=(uchar *)"22C129A700AE7220A5A93A18EFD31E161E4AAFCE276C2E6573D7AE305699EBAB615979AC577FE09D62BC9357871573D765E66B06E5296D7041606F52DF0842E890873FD0FCEA59A5659F153D9CE40FD0443DF931700A1FAAB4AB86872146A2E5B843758E3183E392E0574672C6DC187F2EF2D8C5C2AA4C1AED25E37687840675";
	uchar *uModulus3=(uchar *)"91E04359CB68EC939697CC021EA74FC958013632A06B5619730565E75933B1D2AF8B66D050A8D88D1EB86F5623A8D4FE34C621D519F6F5C34D467AA00FE6A17ED137068B757B2F92A0246F4EE51B45F113DA9F1C0F90D3F1403CC26E9FECFF40E23F44949789C0D9D4B1C7657AAEADC118A97551CD8E9ED134F3829E135D6F444348508E542C5B19C4165EF226EC012C5DBEA598B4DE0D928CFAA8DE3623AFAFCEDEC3E13FC0C2684838FF5930C0754393A9D35D113ED8E77FFFF119B260D0E99EC4ABB6E23C28B69CB6B86F04084AD9162E42D76DA2AD06A03D1F85ABCF77EEEBDB4B1CC3C3B9E792DEAF78ABAC6E009BB25700A0ACC6EB566A708F3F58C759";
	uchar *uExponent3=(uchar *)"60C852C70B9EA47F53058953CAB4A4C9E7FA7DD3DEFCF7D5D0AB3F2DDBCFE165F013E3F5C7DE0E36AAB021261C68924FCA01BE469D806D13D37C343567F753244978617E3B46AC8C727559E8153720134F61D7F88D174096AA50E58AF1CE129820C36B23CEDA9539B0D4F67F0C8342427FB346642CA638168334206FF257264F37D12544A5F1A9EF7682D20249C31E9CD0DDF288BD400BFE76E013A584CDC9B2E3499CC741B8CB6AFC9C3DDDFB7DB6AB3F36C443675C4DFF31D8A5B616CD3D5F981C82E8C9E84C78FF75FF4A95DE065A45A2EB69F8E0D37060BB34FA317A2AD6B957D8F92205B6A4CA93441801C26584E56F3CBFD216ACC3A53223970AA5F345";
//	uchar *uModulus4=(uchar *)"B36ED85AEB6B49AFCE49B69D5578E75532E70E3D7BDC3BE2FFACD91AD22696423F6B02CD012E074B9407E5B53BA69960404718C35B667ED4B63796A2F47EC8F2329B58FBEB80C9E66A7CEE6A8ED3D713693FBA799510C1428286B963281732FA87BE38F1FE63DB0902E3DB1F4A917C7A5EC8DF86DE63FABD4594949EC3AA3534473A7E4B943ED11291CDFC55A61E7EB6FB41B706A5E44EF72A1CCA70B77E096F845D507D049E54944BB556E01119481A4A66FF70F5415C9D27D458ADBCC670A3A618A4702E482C0BB401903D132A9E6A1D32A3234AFBBE03451D73DA19C84D99A0515436CC86314197A54715F2AA5D54F8E6B36BE5AA8D4306B120D6EE3AD3CDE2A080A1E245112FC5F121036A9C1A75FD164605E65F5B083E6369B527B35359EF94E341659036754AAFF3501B34D74B3ACC5197666F07591EE868EA1B840C8E8847A69399481BA9B267CA3F83280ECD85F46A7F66CCBBDE62D6A80B26C1F33256095B8DB48318DC94041A1AC5EFBC7EADD15DFE1B2C46E3B74F9F29615FC9197BC274882D3CE10DA8E321CC36155A277448B03769CD47949F9E748286996BD2085A30042CA2DE65C2296DDDF8AA859B3F3BEB21F84DF9F1DA8D32B109DF8EB9CF11C1FA2128BF10EBF3EC2B5A0D869876FA342A25C025BA97C1B2E7D8A383D043D7B157D4CD4A71BDFFB0D106DAFC83F061445C97D18061B853E3979D5C7C61";
	
	ST_SEC_KCV_INFO stKcvInfoIn;
	ST_SEC_KEY_INFO stKeyInfo;
	uchar sDataIn[MAX_RSA_MODULUS_LEN]={0};
	uchar sDataOut[MAX_RSA_MODULUS_LEN]={0};
	uchar sDataOut1[MAX_RSA_MODULUS_LEN]={0};
	uchar sTMP[MAX_RSA_MODULUS_LEN*2]={0};

//	uchar dataouthex[512]={0};
	if(auto_flag==2)
	{
		//send_result("line %d:%s无纯手动测试用例", __LINE__, TESTAPI);
		return;
	}
	cls_show_msg1(2, "测试%s...", TESTAPI); 
	
	//测试前置:擦除所有密钥
	if((ret=NDK_SecKeyErase())!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		return;
	}

	//安装usBits=512,sModulus由工具生成,sExponent=3, ID=1的公钥
	memset(&RsaKeyIn, 0,sizeof(ST_SEC_RSA_KEY));
	RsaKeyIn.usBits=RSA_KEY_LEN_512;
	strcpy((char *)RsaKeyIn.sExponent, "03");
	memcpy(RsaKeyIn.sModulus, uModulus1, RsaKeyIn.usBits*2/8);	
	if((ret=NDK_SecLoadRsaKey(1, &RsaKeyIn))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	//安装usBits=1024,sModulus和sExponent由工具生成, ID=2的私钥(对应公钥的指数为0x10001)
	memset(&RsaKeyIn, 0,sizeof(ST_SEC_RSA_KEY));
	RsaKeyIn.usBits=RSA_KEY_LEN_1024;
	memcpy(RsaKeyIn.sModulus, uModulus2, RsaKeyIn.usBits*2/8);	
	memcpy(RsaKeyIn.sExponent, uExponent2, RsaKeyIn.usBits*2/8);	
	if((ret=NDK_SecLoadRsaKey(2, &RsaKeyIn))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	//安装公私钥对,其中bit=2048.公钥sExponent=0x10001,对应数据由工具生成。公钥ID=3,私钥ID=4
	memset(&RsaKeyIn, 0,sizeof(ST_SEC_RSA_KEY));
	RsaKeyIn.usBits=RSA_KEY_LEN_2048;
	strcpy((char *)RsaKeyIn.sExponent, "10001");
	memcpy(RsaKeyIn.sModulus, uModulus3, RsaKeyIn.usBits*2/8);	
	if((ret=NDK_SecLoadRsaKey(3, &RsaKeyIn))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}
	
	memcpy(RsaKeyIn.sExponent, uExponent3, RsaKeyIn.usBits*2/8);	
	if((ret=NDK_SecLoadRsaKey(4, &RsaKeyIn))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

//开发反映不支持usBits=4096
#if 0
	//安装usBits=4096,sModulus由工具生成,sExponent=0x10001, ID=5的公钥
	memset(RsaKeyIn, 0,sizeof(RsaKeyIn));
	RsaKeyIn.usBits=4096;
	strcpy(RsaKeyIn.sExponent, "10001");
	memcpy(RsaKeyIn.sModulus, uModulus4, RsaKeyIn.usBits*2/8);
	if((ret=NDK_SecLoadRsaKey(5, &RsaKeyIn))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		//GOTOERR;
	}
#endif

	//安装TDK,ID=6(明文)
	stKeyInfo.ucScrKeyIdx=0;
	stKeyInfo.ucScrKeyType=0;
	stKeyInfo.ucDstKeyIdx=6;
	stKeyInfo.ucDstKeyType=SEC_KEY_TYPE_TDK;
	stKeyInfo.nDstKeyLen=16;	
	memset(stKeyInfo.sDstKeyValue, 0x11, 16);
	stKcvInfoIn.nCheckMode=SEC_KCV_NONE;

	if((ret = NDK_SecLoadKey(&stKeyInfo, &stKcvInfoIn)) != NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	//case1:非法测试
	//case1.1:ucRSAKeyIndex=6返回失败
	if((ret=NDK_SecRecover(6, sDataIn, 64, sDataOut))!=NDK_ERR_SECKM_READ_REC)   /*返回值是否正确，需确认*/
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	//case1.2:ucRSAKeyIndex=10,101 返回失败
	if((ret=NDK_SecRecover(10, sDataIn, 64, sDataOut))!=NDK_ERR_SECKM_READ_REC)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}
	
	if((ret=NDK_SecRecover(101, sDataIn, 64, sDataOut))!=NDK_ERR_SECKM_READ_REC)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	//case1.3:psDataIn=NULL
	if((ret=NDK_SecRecover(1, NULL, 64, sDataOut))!=NDK_ERR_PARA )
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}
	
	//case1.4:nDataInLen<0
	if((ret=NDK_SecRecover(1, sDataIn, -1, sDataOut))!=NDK_ERR_PARA)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	//case1.5:psDataOut=NULL
	if((ret=NDK_SecRecover(1, sDataIn, 64, NULL))!=NDK_ERR_PARA)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	//case1.6:psDataIn的第一个字节必须小于psModule的第一个字节,否则返回失败 linwl20131015
	memset(sDataIn, 'a', sizeof(sDataIn));
	sDataIn[0]=0xAC;
	sDataIn[1]=0x1D;
	if((ret=NDK_SecRecover(1, sDataIn, 64, sDataOut))!=NDK_ERR_SECP_PARAM)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}
	
	//case2:用ID=1的密钥对25个字节进行加密。//输入数据长度必须和模等长
	memset(sDataIn, 'a', sizeof(sDataIn));
	if((ret=NDK_SecRecover(1, sDataIn, 25, sDataOut))!=NDK_ERR_SECP_PARAM)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	//case3:用ID=1的密钥对64个字节进行加密。
	if((ret=NDK_SecRecover(1, sDataIn, 64, sDataOut))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}
	NDK_AscToHex((uchar *)"94BA998673DA14FCCF210C1E3584DEC488B4EDF2C8D88797249A117C59205BDFE3B76DBCE7F83B40B0F19A8C5C681EEEB953A1FBD386EC0A7E47FFB4A3B7DFD3", 128, 0, sTMP);

	if(memcmp(sDataOut, sTMP, 64))
	{
		send_result("line %d:%s测试失败", __LINE__, TESTAPI);
		GOTOERR;
	}

	//case4:用ID=1的密钥对65个字节进行加密。应报错
	if((ret=NDK_SecRecover(1, sDataIn, 65, sDataOut))!=NDK_ERR_SECP_PARAM)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	//case5:用ID=2的密钥对31个字节进行加密。//数据长度应与模长相等
	if((ret=NDK_SecRecover(2, sDataIn, 31, sDataOut))!=NDK_ERR_SECP_PARAM)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	//case6:用ID=2的密钥对128个字节进行加密。
	if((ret=NDK_SecRecover(2, sDataIn, 128, sDataOut))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	NDK_AscToHex((uchar *)"311451E9A4642D7C66E3705E8EAC130EDAF423149AE84563A5F6B787DFBD911D5452A944FA973F78350B6F6282365E6BA6DE5FFFC4F3CC981886600EBECCA98CFC67D46020CA066EBF20F6156FB0FC8072880CE439EC2B70EC990D60A2C0B590F58747D570863471BAE3395A6F290F0D9319DE0C2D5F51F93F9A0CFC13AB38D0", 256, 0, sTMP);

	if(memcmp(sDataOut, sTMP, 128))
	{
		send_result("line %d:%s测试失败", __LINE__, TESTAPI);
		GOTOERR;
	}
	
//开发反映输入字节长度与模不等长时，返回错误码
#if 0    
	//case7:用ID=3的密钥对31个字节进行加密,用ID=4的密钥对结果进行解密。2次运算结果应与预期一致
	if((ret=NDK_SecRecover(3, sDataIn, 31, sDataOut))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}
	
	NDK_AscToHex("65451BB0D34A4A30A38D24445B4E2B5235D74F6992B4DD44FF8E8A71DB170C089C1B06C1AE1319E9A55ECA686D7D824035F3CF891E355DD45985FF8856A6D2CC06318A1AAC2D96B80F8AAE404EE499383C27B04FD8544D572A7FDCCD567EFE92E869C7BF3411F7CE01DA576C1079E7C9A4B2A9650A6DC432089EC8BF370470A833CFCDE3AEA3B1245A002EDA5D25D2DB1A758C89BBEF4B870F3253E06C406021B88B6C7D78DB48F732A73008AC5AB347785AD15FB92B9C2B488FDECBE715389C7282E1DD4BA018B54383AE398AA9447E3990DBB3526DB4B655F5F71104ADDD950A27AE85E21305BF2D6734CE82D78350FBC88A273093380421D712686062FD0B", 512, 0, sTMP);

	for(i=0; i<256; i++)
	{
		if(sDataOut[i]!=sTMP[i])
		{
			send_result("line %d:%s测试失败(%d, %x, %x)", __LINE__, TESTAPI, i, sDataOut[i], sTMP[i]);
			GOTOERR;
		}	
	}

	if((ret=NDK_SecRecover(4, sDataOut, 31, sDataOut1))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}

	NDK_AscToHex("4ED67A8540B86B14BA52E6EF2F31DAC32B36DFFA29F2488D6ACBBCCDF07CF14873DC710735B9ECC2855DE04AAD70AC7C37BC487490FC3E9BC12656BBB7BB10F6CFE7A1C8107A65B1F8AC4DB99FAEFF2B3B3C11ADED0AA5930372E6118796735B304CABCD0DC957C3C4E8D239BE5864B6EE1C5CEF545015C5C4BEAA7F82B1F0017C5A6A0692B95530E134FE4140872BE70B0BEA2C5511E37C7924764884657F4499950B6470528D434F0556563583418B5294A0CAF7F3FD7F04F1E1933814D2CD00AA09EBE9FE08C102787DC6DC87DC106AC34766DC7F51D38F3D97CF8B90B3679C953E2ACDE193F4902D107AC8FA538DEA2E16F2D30C5E868478A918A10D05", 512, 0, sTMP);

	for(i=0; i<256; i++)
	{
		if(sDataOut1[i]!=sTMP[i])
		{
			send_result("line %d:%s测试失败(%d, %x, %x)", __LINE__, TESTAPI, i, sDataOut1[i], sTMP[i]);
			GOTOERR;
		}	
	}
#endif

	//case8:用ID=3的密钥对256个字节进行加密,用ID=4的密钥对结果进行解密。加密结果应与预期一致,且解密结果应还原成初始数据
	memset(sDataIn, 'b', sizeof(sDataIn));
	if((ret=NDK_SecRecover(3, sDataIn, 256, sDataOut))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}
	
	NDK_AscToHex((uchar *)"483FE64913A9F15B1F1BE6FF7B107A808FA0C7AD78434D5F666A9DDB27D93705205E83CE0B060D9D504DF95BC45CACD6EDF3D9244F1DDA1FC2512BC8B16CF9748F2DE527FE4CE02448B279ACF3ECCC9589B44B20822F258199E8A0E68DC895BEED65ECF5636CB2B04EBE472437AAD92F711ACAA3A35D74E796200553D0C0B95A19B5606F302DDC8EDA63F82A22F280B557D7EB5E45856A28BF1A95714FF48A99AD8C55111CFAD18A63411BEBFE7CACEE98E5BCDE8F8EA813BE715E6016485625823391DE7202EA34182B0FD4D1C1350F55118AC7F1409072A5AC952B25EEF16C22C2E03E648BCC951849DDE12389E9CE3E1E1A2A794E3C83F78AE5FF1B35E971", 512, 0, sTMP);

	if(memcmp(sDataOut, sTMP, 256))
	{
		send_result("line %d:%s测试失败", __LINE__, TESTAPI);
		GOTOERR;
	}

	if((ret=NDK_SecRecover(4, sDataOut, 256, sDataOut1))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}
	if(memcmp(sDataIn, sDataOut1, 256))
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		goto ERR;
	}

//开发反映不支持usBits=4096  。ID=5是用usBits=4096安装的密钥
#if 0
	//case9:用ID=5的密钥对499个字节进行加密。
	memset(sDataIn, 0x22, 499);
	if((ret=NDK_SecRecover(5, sDataIn, 499, sDataOut))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}
	memcpy(sTMP, "74BEB30F7A842F6A3AFA71316FC02731E7B541CC3785C8472E158343AF07E5D3F5439D7F2FDD0550D1018EE7C2C41EF97F4A6C1304E1ED1ABBAC23242662BA89D31CF05CFE2B820C81AC0F84B28CC2CD96913BF22234BF675422B171EF9A68234FDC0A74D8E9E5D00834A6D09E44BD574A764977A4BA59DAEEB1DC8F61C269B05AE40CEC07E2C4CA378F943F2D1FE48B5E338B83257FAF5070A25B80D382B3072A5FBDE11B030826918D52F8EB7C5735A800870CBD5E9B661AAADEE52E1E75B004AB79CB13D6625FFCE93AAEAD432E7E29A3D55F321A086CAE5C17DF5435C0807793588C15302EE50B1B90C95056FDC60D5BFF445EF168F6D95F06698D3D52A289D7AB32C1EDF5519127032A41E9ED77CF0BA633532C7DFFE4A968A593D1B46C66D940A460170C0F5B08A7B0220CC4B7DE6084715DEA65F51BC97D2D6B9990C847FC88881700E60414D9E156B14B9536F08B37CD1729DC0CD91AD5AAFD96D33F53979CBBC5AE816E4AF63D1887C83CBFB1C3814807E6A3F920DD60F0389B5821B6F11B8D1C9B644F5FC8C9970E075723B81B6A308C996F732E20144CCC0609E1FD65E1FFF6C8800DD93989E456EF5F44FBA31C4DE9F10DACD34DFDB5D8D55736C221B40CAB7C84EBCA35E47BDD20F29BA304CD3658AA4FC5DEF3334DD28D6B26BA2F730624DCFB79178C623675DF670F4BCEC26C9A56860F0C472705685AF0F8", 512*2);
	for(i=0; i<512; i++)
	{
		if(sDataOut[i]!=sTMP[i]*16+sTMP[i+1])
		{
			send_result("line %d:%s测试失败(%d, %x, %x)", __LINE__, TESTAPI, i, sDataOut[i], sTMP[i]*16+sTMP[i+1]);
			GOTOERR;
		}	
	}
	
	//case10:用ID=5的密钥对512个字节进行加密。
	memset(sDataIn, 0x22, 512);
	if((ret=NDK_SecRecover(5, sDataIn, 512, sDataOut))!=NDK_OK)
	{
		send_result("line %d:%s测试失败(%d)", __LINE__, TESTAPI, ret);
		GOTOERR;
	}
	memcpy(sTMP, "67520819A86468D895B2CCC022EB9E6CF6F68824CB63B356FC38A0FD496E9389D3C05972C65FA34CDCBFF0047446C836DAB6E5366B03B3E8D3903A4BB32DA08DB367FF45F629A2082AA899F6D15DBF7160809476F0C06416D77C80453B11910FD211EC92CA09EDDCEEA67E0F794992B1333251D08FB689EA5A7A75BEAB5A6ADA8A59E7C5B9A8743A96B54A020725B187B357CF2D468AA4C525CF93163C12039104F0CEF890EFF158108EFB4552B0CEA74DFAFA25706041786904D587BA3F6F507F5730AA71B8B369EB94B637C0E55B941DA25CD236D2A25489F204F512266A16C4207BF26DAF14C4F55BE646B976FBF8D23C0574207043F3228FFA4462ED2574CD9E366964CA87B1BD8A055451F19671758A5579E9FF34979131B34186B9E0A96B6A6537D7DC5A93F70FF640775B13B927AF1FE834F369854F993715EFBC0C4EFC8E275D367704FDC91450F94AA76FB823371663D6CC8ABEAA0F19AF9573686229B7C8A56910EC379AD2C24AC7044D0E46A637942FC9A8EF35AE1273837CC0422E9E06C5DEA187E2959BC1B4985EDD4CD62CAD7BEC4D6FA22341DFEC068B08A95EE2CACEB31BB8469B5E46C84569EC9F64E67DB92DA1204E580E378E47CD4042B7E088036240F31711105B1387E582C4D1C67742A907AA33A42F074340075962C38ACA3086EBED3FC04683E4C5FFF8444C70677B75A93C4E35154E9BCC1640B9", 512*2);
	for(i=0; i<512; i++)
	{
		if(sDataOut[i]!=sTMP[i]*16+sTMP[i+1])
		{
			send_result("line %d:%s测试失败(%d, %x, %x)", __LINE__, TESTAPI, i, sDataOut[i], sTMP[i]*16+sTMP[i+1]);
			GOTOERR;
		}	
	}
#endif

	send_result("%s测试通过", TESTAPI);
ERR://测试后置:擦除所有密钥
	NDK_SecKeyErase();
	return;
}

