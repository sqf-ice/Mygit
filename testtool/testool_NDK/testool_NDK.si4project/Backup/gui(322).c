
/************************************************************************
*
* copyright(c)2005-2008 Newland Co. Ltd. All rights reserved
* module			: 简易图形用户界面
* file name		: gui.c
* Author 			: zhangnw
* version			: V1.0
* DATE			: 20060410
* directory 		: .\SRC\main\
* description		: 
* related document	: 
* 
************************************************************************/
/*-----------------------includes-------------------------------*/
#include "mode.h"
#include "systest.h"

/*---------------constants/macro definition---------------------*/

/*------------global variables definition-----------------------*/
#if PRN_ENABLE||!SCR_DISABLE
const char NL_Icon[/*32*/]=
{
	0x01,0x80,0x03,0xc0,0x07,0xe0,0x0f,0xf0,
	0x1f,0xf8,0x3f,0xfc,0x3d,0xfc,0x1a,0xf8,
	0x05,0x74,0x0a,0xaa,0x15,0x54,0x0a,0xa8,
	0x05,0x50,0x02,0xa0,0x01,0x40,0x00,0x80
};

// 新大陆广告图(128*64)
const char NL_BMP[/*1024*/]=
{
		0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xfe, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xfc, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xf8, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xf0, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xe0, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xc0, 0x00, 0x3f, 0xff, 0xff, 0x87, 0xc0, 
		0x03, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0x80, 0x00, 0x1f, 0xff, 0xf8, 0x00, 0x40, 
		0x07, 0xff, 0xe0, 0xff, 0xfc, 0x00, 0xfc, 0x3f, 
		0xff, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x00, 0x40, 
		0x0f, 0xc0, 0x00, 0x00, 0x3c, 0x00, 0xc0, 0x03, 
		0xfe, 0x00, 0x00, 0x07, 0xff, 0xfc, 0x30, 0xc1, 
		0xff, 0xc0, 0x00, 0x00, 0x3c, 0x00, 0xc0, 0x03, 
		0xfc, 0x00, 0x00, 0x03, 0xff, 0xfe, 0x31, 0xc1, 
		0xff, 0xc0, 0x00, 0x00, 0x3c, 0x30, 0xc0, 0x03, 
		0xf8, 0x00, 0x00, 0x01, 0xff, 0xfe, 0x31, 0xc0, 
		0x03, 0xc0, 0x00, 0x00, 0x3c, 0x30, 0xfc, 0x3f, 
		0xf0, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x40, 
		0x03, 0xff, 0xc1, 0xff, 0xfc, 0x31, 0xfc, 0x3f, 
		0xe0, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x40, 
		0x03, 0xff, 0x83, 0xff, 0xfc, 0x01, 0x80, 0x01, 
		0xc0, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x87, 0xc3, 
		0x0f, 0xff, 0x80, 0xff, 0xfc, 0x01, 0x80, 0x01, 
		0x80, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x43, 
		0x0f, 0xff, 0x00, 0x7f, 0xfc, 0x01, 0x80, 0x01, 
		0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x43, 
		0x0f, 0xff, 0x0e, 0x3f, 0xfc, 0x01, 0xfc, 0x3f, 
		0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x43, 
		0x0f, 0xfe, 0x0f, 0x1f, 0xfc, 0x31, 0xfc, 0x3f, 
		0x80, 0x38, 0x00, 0x00, 0x1f, 0xff, 0x87, 0xc3, 
		0x0f, 0xfc, 0x1f, 0x0f, 0xfc, 0x31, 0x8c, 0x31, 
		0xc0, 0x7c, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0xc3, 
		0x0f, 0xfc, 0x3f, 0x87, 0xfc, 0x31, 0x8c, 0x31, 
		0xe0, 0xe6, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x43, 
		0x0f, 0xf8, 0x3f, 0x83, 0xfc, 0x21, 0x8c, 0x31, 
		0xf1, 0xcf, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x43, 
		0x0f, 0xf0, 0x7f, 0xc1, 0xfc, 0x01, 0x8c, 0x31, 
		0xfb, 0x9d, 0x80, 0x01, 0xff, 0xf8, 0x84, 0x43, 
		0x0f, 0xf0, 0x7f, 0xe0, 0xfc, 0x03, 0x8c, 0x31, 
		0xff, 0x39, 0xc0, 0x03, 0xff, 0xf0, 0x84, 0x07, 
		0x0f, 0xe0, 0xff, 0xe0, 0x7c, 0x07, 0x80, 0x01, 
		0xfe, 0x73, 0xe0, 0x07, 0xff, 0xf0, 0x86, 0x07, 
		0x0f, 0xc1, 0xff, 0xf0, 0x3c, 0x3f, 0x80, 0x01, 
		0xfc, 0xe7, 0x30, 0x0e, 0xff, 0xf1, 0x86, 0x07, 
		0x0f, 0x81, 0xff, 0xf0, 0x1c, 0x3f, 0x80, 0x01, 
		0xf9, 0xce, 0x78, 0x1c, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x01, 
		0xf3, 0x9c, 0xec, 0x39, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xe7, 0x39, 0xce, 0x73, 0x9f, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xce, 0x73, 0x9f, 0xe7, 0x3f, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0x9c, 0xe7, 0x39, 0xce, 0x77, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0x39, 0xce, 0x73, 0x9c, 0xe7, 0xf9, 0xf1, 0xf8, 
		0x3f, 0x3e, 0x31, 0xf9, 0xff, 0x9f, 0x8c, 0x0f, 
		0x73, 0x9c, 0xe7, 0x39, 0xcf, 0xf8, 0xf1, 0xf0, 
		0x1f, 0x1e, 0x31, 0xf8, 0xff, 0x8f, 0x8c, 0x07, 
		0xe7, 0x39, 0xce, 0x73, 0x9f, 0xf8, 0x71, 0xe0, 
		0x0f, 0x0e, 0x31, 0xf8, 0x7f, 0x87, 0x8c, 0x63, 
		0xce, 0x73, 0x9c, 0xe7, 0x3f, 0xf8, 0x31, 0xc3, 
		0x07, 0x06, 0x31, 0xf8, 0x3f, 0x83, 0x8c, 0x71, 
		0xfc, 0xe7, 0x39, 0xce, 0x7f, 0xf8, 0x11, 0x87, 
		0x83, 0x02, 0x31, 0xf8, 0x1f, 0x81, 0x8c, 0x78, 
		0xf9, 0xce, 0x73, 0x9c, 0xff, 0xf8, 0x01, 0x8f, 
		0xc1, 0x00, 0x31, 0xf8, 0x0f, 0x80, 0x8c, 0x78, 
		0xfb, 0x9c, 0xe7, 0x39, 0xff, 0xf8, 0x01, 0x80, 
		0xe0, 0x00, 0x31, 0xf8, 0x87, 0x80, 0x0c, 0x78, 
		0xff, 0x39, 0xce, 0x73, 0xff, 0xf8, 0x01, 0x80, 
		0x70, 0x00, 0x31, 0xf8, 0xc3, 0x88, 0x0c, 0x78, 
		0xfe, 0x73, 0x9c, 0xe7, 0xff, 0xf8, 0x81, 0x8f, 
		0xf8, 0x10, 0x31, 0xf8, 0xe1, 0x8c, 0x0c, 0x78, 
		0xff, 0xe7, 0x39, 0xcf, 0xff, 0xf8, 0xc1, 0x87, 
		0xfc, 0x18, 0x31, 0xf8, 0x00, 0x8e, 0x0c, 0x70, 
		0xff, 0xce, 0x73, 0x9f, 0xff, 0xf8, 0xe1, 0xc3, 
		0xfe, 0x1c, 0x31, 0xf8, 0x00, 0x0f, 0x0c, 0x61, 
		0xff, 0xdc, 0xe7, 0x3f, 0xff, 0xf8, 0xf1, 0xe0, 
		0x0f, 0x1e, 0x30, 0x18, 0x00, 0x0f, 0x8c, 0x03, 
		0xff, 0xf9, 0xce, 0x7f, 0xff, 0xf8, 0xf9, 0xf0, 
		0x07, 0x9f, 0x30, 0x18, 0xfe, 0x0f, 0xcc, 0x07, 
		0xff, 0xf3, 0x9c, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xfe, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xfe, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x03, 0xc1, 0x04, 0x20, 0x04, 0x08, 0x20, 0x20, 
		0x00, 0x10, 0x00, 0xa0, 0x04, 0x00, 0x42, 0x80, 
		0x01, 0x09, 0x04, 0xfe, 0x0a, 0x08, 0xfd, 0xc0, 
		0x02, 0xfe, 0x00, 0x90, 0x07, 0xe1, 0xe7, 0xc0, 
		0x01, 0x05, 0x04, 0x20, 0x11, 0x48, 0x4a, 0x00, 
		0x00, 0x82, 0x1f, 0xfc, 0x04, 0x00, 0x4a, 0x00, 
		0x03, 0xc3, 0x0e, 0x20, 0x20, 0xc8, 0x4a, 0x00, 
		0x00, 0x82, 0x00, 0x80, 0x7f, 0xe0, 0x4a, 0x00, 
		0x01, 0x91, 0x04, 0xfc, 0x1f, 0x48, 0xff, 0xf0, 
		0x06, 0xfe, 0x08, 0x88, 0x40, 0x20, 0xf9, 0x80, 
		0x01, 0x49, 0x04, 0x84, 0x21, 0x48, 0x22, 0x40, 
		0x02, 0x80, 0x08, 0x90, 0x7f, 0xe1, 0x49, 0x80, 
		0x03, 0x45, 0x06, 0x44, 0x21, 0x48, 0xfe, 0x40, 
		0x02, 0xff, 0x05, 0xe0, 0x40, 0x21, 0x49, 0x80, 
		0x03, 0x41, 0x0c, 0x48, 0x25, 0x48, 0x72, 0x40, 
		0x02, 0x81, 0x02, 0xa0, 0x7f, 0xe1, 0x7b, 0x00, 
		0x05, 0x3f, 0x84, 0x30, 0x22, 0x08, 0x6a, 0x40, 
		0x02, 0x81, 0x04, 0xa0, 0x02, 0x01, 0xce, 0xc0, 
		0x01, 0x01, 0x04, 0x30, 0x20, 0x88, 0xaa, 0x40, 
		0x02, 0xff, 0x08, 0x90, 0xff, 0xf1, 0xc2, 0xc0, 
		0x01, 0x01, 0x04, 0xcc, 0x20, 0x88, 0x2a, 0x40, 
		0x05, 0x00, 0x10, 0x8c, 0x02, 0x02, 0x64, 0x00, 
		0x01, 0x01, 0x0f, 0x02, 0x1f, 0x38, 0x64, 0x40, 
		0x04, 0xff, 0x03, 0x00, 0x02, 0x02, 0x1f, 0xc0, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 建行广告图(128*64)
const char CCB_BMP[/*1024*/]=
{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x3f, 0xff, 0xfe, 0xff, 0xe7, 0x3f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x90, 0xff, 0xfc, 0x7f, 0xe7, 0x3f, 0xfe, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x9e, 0xff, 0x1c, 0xff, 0xe7, 0x3f, 0xfe, 
	0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xbf, 0xff, 0x3c, 0xff, 0xcf, 0x07, 0xfe, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x01, 0xff, 0x79, 0xbf, 0xd8, 0x3f, 0xfe, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfc, 0x1f, 0xfe, 0x88, 0x0f, 0x8f, 0x7b, 0xfc, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfb, 0x0d, 0xfc, 0x43, 0x9f, 0x0f, 0x01, 0xfc, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x48, 0xfc, 0xc7, 0x9f, 0x40, 0x7f, 0xf9, 
	0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0x59, 0xfc, 0x09, 0x9e, 0xce, 0x6f, 0xf9, 
	0x9f, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0xd3, 0xfe, 0xcc, 0x9f, 0xce, 0x07, 0xf3, 
	0x8f, 0xff, 0xf0, 0x3e, 0xff, 0xff, 0xff, 0xff, 
	0xfc, 0xc7, 0xde, 0xcf, 0x9f, 0xcc, 0xcf, 0xe7, 
	0xc7, 0xff, 0xfc, 0x7e, 0x7f, 0xff, 0xff, 0xff, 
	0xf9, 0xcf, 0xde, 0x0f, 0x9f, 0xcf, 0xdf, 0xcf, 
	0xe3, 0xff, 0xfc, 0x78, 0xcf, 0xff, 0xff, 0xff, 
	0xfb, 0x8f, 0x9e, 0x8f, 0x9f, 0xce, 0x3f, 0x9f, 
	0xf0, 0xff, 0xfc, 0xfc, 0x87, 0xff, 0xff, 0xff, 
	0xf6, 0x47, 0x1f, 0xfc, 0x1f, 0xcf, 0x1f, 0x7f, 
	0xff, 0xff, 0x80, 0x19, 0xa3, 0xff, 0xff, 0xff, 
	0xef, 0xe0, 0x1f, 0xfe, 0x3f, 0xff, 0x9f, 0xff, 
	0xff, 0xff, 0xc0, 0x79, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xf0, 0x7f, 0xff, 0x7f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xf8, 0xf8, 0x0f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xc7, 0xb9, 0xcf, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xc7, 0x3b, 0xcf, 0xff, 0xcf, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0xff, 0xf4, 0x3e, 0x1f, 0xff, 0xcc, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
	0x18, 0xff, 0xfc, 0x30, 0x7f, 0xff, 0xe3, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0xdd, 0xff, 0xe0, 0xe1, 0xff, 0xff, 0xef, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0xdd, 0xfe, 0x03, 0xef, 0xff, 0xff, 0xef, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
	0x01, 0xfe, 0x60, 0x2c, 0x0f, 0xff, 0xe0, 0x0f, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0xdd, 0xff, 0xe3, 0x27, 0x6f, 0xf0, 0x0f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0xd9, 0xff, 0xc7, 0x26, 0x3f, 0xff, 0xcf, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
	0x01, 0xff, 0xc3, 0x24, 0x1f, 0xff, 0xcb, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
	0xdd, 0xff, 0x83, 0x27, 0x7f, 0xff, 0xc0, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 
	0xdc, 0xff, 0x91, 0x26, 0x18, 0xff, 0xce, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 
	0x9c, 0xff, 0x99, 0x24, 0x08, 0xff, 0xcf, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 
	0x94, 0xff, 0x99, 0x26, 0x7c, 0xff, 0xcf, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 
	0xb8, 0xff, 0x9f, 0x27, 0xf8, 0xff, 0xcf, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 
	0xf9, 0xff, 0xcc, 0x31, 0xf3, 0xff, 0xcf, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xce, 0x70, 0x87, 0xff, 0xcf, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xce, 0x78, 0x0f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xce, 0xfc, 0x3f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xe7, 0x80, 0x60, 0x00, 0x30, 0x0c, 0x19, 
	0xf8, 0x60, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 
	0x0f, 0xf3, 0x80, 0x60, 0x7f, 0xff, 0xff, 0x8d, 
	0x98, 0x6f, 0xe3, 0x7f, 0x07, 0x87, 0x9f, 0xc0, 
	0x1f, 0xf9, 0x80, 0x66, 0x60, 0x30, 0xcd, 0x8d, 
	0x98, 0xfc, 0x6f, 0x80, 0x0c, 0xcc, 0xd8, 0x60, 
	0x1f, 0xfc, 0x0f, 0xff, 0x7f, 0xf1, 0xff, 0xc1, 
	0x98, 0xcf, 0xe1, 0x80, 0x18, 0x58, 0x58, 0x60, 
	0x1f, 0x9e, 0x0c, 0x66, 0x66, 0x33, 0x0d, 0xbf, 
	0x0f, 0xfc, 0x63, 0xff, 0x98, 0x18, 0x18, 0x60, 
	0x3f, 0x08, 0x0c, 0x66, 0x7f, 0xf7, 0xff, 0x8d, 
	0xf8, 0x6f, 0xe7, 0x06, 0x18, 0x18, 0x1f, 0xc0, 
	0x3e, 0x07, 0x8f, 0xfe, 0x67, 0xb0, 0xcc, 0x0d, 
	0x98, 0x6f, 0x0f, 0x06, 0x18, 0x18, 0x18, 0x60, 
	0x3f, 0x0f, 0x8c, 0x66, 0x66, 0xf3, 0xff, 0x8c, 
	0xf1, 0xff, 0xe3, 0x06, 0x18, 0x18, 0x18, 0x60, 
	0x3f, 0x9f, 0x80, 0x60, 0x7f, 0xf1, 0x8c, 0x0f, 
	0xf0, 0x6d, 0x83, 0x06, 0x18, 0x58, 0x58, 0x60, 
	0x1f, 0xff, 0x00, 0x60, 0x60, 0x31, 0xff, 0xce, 
	0x60, 0x7d, 0x83, 0x06, 0x0c, 0xcc, 0xd8, 0x60, 
	0x1f, 0xff, 0x00, 0x60, 0x7f, 0xf3, 0xcc, 0x0d, 
	0xf8, 0x7f, 0xc3, 0x36, 0x07, 0x87, 0x9f, 0xc0, 
	0x0f, 0xfe, 0x00, 0x60, 0x60, 0x36, 0x7f, 0xc7, 
	0x0e, 0x6e, 0x73, 0x1c, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 建行广告图(144*64)
const char CCB_BMP_144[/*1152*/]=
{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0x3f, 0xff, 0xfe, 0xff, 0xe7, 0x3f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0x90, 0xff, 0xfc, 0x7f, 0xe7, 0x3f, 0xfe, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0x9e, 0xff, 0x1c, 0xff, 0xe7, 0x3f, 0xfe, 
	0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0xbf, 0xff, 0x3c, 0xff, 0xcf, 0x07, 0xfe, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0x01, 0xff, 0x79, 0xbf, 0xd8, 0x3f, 0xfe, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xfc, 0x1f, 0xfe, 0x88, 0x0f, 0x8f, 0x7b, 0xfc, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xfb, 0x0d, 0xfc, 0x43, 0x9f, 0x0f, 0x01, 0xfc, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0x48, 0xfc, 0xc7, 0x9f, 0x40, 0x7f, 0xf9, 
	0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xfe, 0x59, 0xfc, 0x09, 0x9e, 0xce, 0x6f, 0xf9, 
	0x9f, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xfe, 0xd3, 0xfe, 0xcc, 0x9f, 0xce, 0x07, 0xf3, 
	0x8f, 0xff, 0xf0, 0x3e, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xfc, 0xc7, 0xde, 0xcf, 0x9f, 0xcc, 0xcf, 0xe7, 
	0xc7, 0xff, 0xfc, 0x7e, 0x7f, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xf9, 0xcf, 0xde, 0x0f, 0x9f, 0xcf, 0xdf, 0xcf, 
	0xe3, 0xff, 0xfc, 0x78, 0xcf, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xfb, 0x8f, 0x9e, 0x8f, 0x9f, 0xce, 0x3f, 0x9f, 
	0xf0, 0xff, 0xfc, 0xfc, 0x87, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xf6, 0x47, 0x1f, 0xfc, 0x1f, 0xcf, 0x1f, 0x7f, 
	0xff, 0xff, 0x80, 0x19, 0xa3, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xef, 0xe0, 0x1f, 0xfe, 0x3f, 0xff, 0x9f, 0xff, 
	0xff, 0xff, 0xc0, 0x79, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0xf0, 0x7f, 0xff, 0x7f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xf8, 0xf8, 0x0f, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xc7, 0xb9, 0xcf, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xc7, 0x3b, 0xcf, 0xff, 0xcf, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xe0, 0xff, 0xf4, 0x3e, 0x1f, 0xff, 0xcc, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
	0x18, 0xff, 0xfc, 0x30, 0x7f, 0xff, 0xe3, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0xdd, 0xff, 0xe0, 0xe1, 0xff, 0xff, 0xef, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0xdd, 0xfe, 0x03, 0xef, 0xff, 0xff, 0xef, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
	0x01, 0xfe, 0x60, 0x2c, 0x0f, 0xff, 0xe0, 0x0f, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0xdd, 0xff, 0xe3, 0x27, 0x6f, 0xf0, 0x0f, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0xd9, 0xff, 0xc7, 0x26, 0x3f, 0xff, 0xcf, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
	0x01, 0xff, 0xc3, 0x24, 0x1f, 0xff, 0xcb, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
	0xdd, 0xff, 0x83, 0x27, 0x7f, 0xff, 0xc0, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 
	0xdc, 0xff, 0x91, 0x26, 0x18, 0xff, 0xce, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 
	0x9c, 0xff, 0x99, 0x24, 0x08, 0xff, 0xcf, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 
	0x94, 0xff, 0x99, 0x26, 0x7c, 0xff, 0xcf, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 
	0xb8, 0xff, 0x9f, 0x27, 0xf8, 0xff, 0xcf, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 
	0xf9, 0xff, 0xcc, 0x31, 0xf3, 0xff, 0xcf, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xce, 0x70, 0x87, 0xff, 0xcf, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xce, 0x78, 0x0f, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xce, 0xfc, 0x3f, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff,0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x01, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x07, 0xe7, 0x80, 0x60, 0x00, 0x30, 0x0c, 0x19, 
	0xf8, 0x60, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x0f, 0xf3, 0x80, 0x60, 0x7f, 0xff, 0xff, 0x8d, 
	0x98, 0x6f, 0xe3, 0x7f, 0x07, 0x87, 0x9f, 0xc0, 
	0xff,0xff,
	0x1f, 0xf9, 0x80, 0x66, 0x60, 0x30, 0xcd, 0x8d, 
	0x98, 0xfc, 0x6f, 0x80, 0x0c, 0xcc, 0xd8, 0x60, 
	0xff,0xff,
	0x1f, 0xfc, 0x0f, 0xff, 0x7f, 0xf1, 0xff, 0xc1, 
	0x98, 0xcf, 0xe1, 0x80, 0x18, 0x58, 0x58, 0x60, 
	0xff,0xff,
	0x1f, 0x9e, 0x0c, 0x66, 0x66, 0x33, 0x0d, 0xbf, 
	0x0f, 0xfc, 0x63, 0xff, 0x98, 0x18, 0x18, 0x60, 
	0xff,0xff,
	0x3f, 0x08, 0x0c, 0x66, 0x7f, 0xf7, 0xff, 0x8d, 
	0xf8, 0x6f, 0xe7, 0x06, 0x18, 0x18, 0x1f, 0xc0, 
	0xff,0xff,
	0x3e, 0x07, 0x8f, 0xfe, 0x67, 0xb0, 0xcc, 0x0d, 
	0x98, 0x6f, 0x0f, 0x06, 0x18, 0x18, 0x18, 0x60, 
	0xff,0xff,
	0x3f, 0x0f, 0x8c, 0x66, 0x66, 0xf3, 0xff, 0x8c, 
	0xf1, 0xff, 0xe3, 0x06, 0x18, 0x18, 0x18, 0x60, 
	0xff,0xff,
	0x3f, 0x9f, 0x80, 0x60, 0x7f, 0xf1, 0x8c, 0x0f, 
	0xf0, 0x6d, 0x83, 0x06, 0x18, 0x58, 0x58, 0x60, 
	0xff,0xff,
	0x1f, 0xff, 0x00, 0x60, 0x60, 0x31, 0xff, 0xce, 
	0x60, 0x7d, 0x83, 0x06, 0x0c, 0xcc, 0xd8, 0x60, 
	0xff,0xff,
	0x1f, 0xff, 0x00, 0x60, 0x7f, 0xf3, 0xcc, 0x0d, 
	0xf8, 0x7f, 0xc3, 0x36, 0x07, 0x87, 0x9f, 0xc0, 
	0xff,0xff,
	0x0f, 0xfe, 0x00, 0x60, 0x60, 0x36, 0x7f, 0xc7, 
	0x0e, 0x6e, 0x73, 0x1c, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff,0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff,0xff
};
#endif

#if !(defined ME15CHX||defined ME15B||defined ME66)//ME15C为节省应用空间不编译不用的函数 20170213 linwl
static uint g_LCDWidth = 0;
static uint g_LCDHeight = 0;

//英文字符高度和宽度，用于显示修正
static uint g_frontWidth = 0;
static uint g_frontHeight = 0;

//static int overflag = TRUE;
/*---------------functions declaration--------------------------*/

/*---------------functions definition---------------------------*/
uint GUI_GetLCDWidth(void){return g_LCDWidth;}
uint GUI_GetLCDHeight(void){return g_LCDHeight;}
uint GUI_GetFontWidth(void){return g_frontWidth;}
uint GUI_GetFontHeight(void){return g_frontHeight;}

#if OVERSEAS_ENABLE
int NDK_SecSetCfg(uint unCfgInfo){return NDK_OK;}
int NDK_SecGetCfg(uint * punCfgInfo){return NDK_OK;}
#endif

#if !(ANDIROD_ENABLE||defined ME15C)
int GUI_GetLCDSize(void){return NDK_ScrGetLcdSize(&g_LCDWidth, &g_LCDHeight);}
int GUI_GetFontSize(void){return NDK_ScrGetFontSize(&g_frontWidth, &g_frontHeight);}
#else
int GUI_GetLCDSize(void){g_LCDWidth=128;g_LCDHeight=64;return NDK_OK;}
//int NDK_ScrClrs(void){return NDK_OK;}
int NDK_ScrSetAttr(EM_TEXT_ATTRIBUTE emNewAttr, EM_TEXT_ATTRIBUTE *pemOldAttr){return NDK_OK;}
//int NDK_ScrPrintf(const char *psFormat, ...){return NDK_OK;}
int NDK_ScrGetxy(uint * punX,uint * punY){return NDK_OK;}
int NDK_ScrGotoxy(uint unX,uint unY){return NDK_OK;}
int NDK_ScrGetFontSize(uint * punWidth,uint * punHeight){*punWidth=16;*punHeight=16;return NDK_OK;}
int NDK_ScrDispString(uint unX,uint unY,const char * pszS,uint unMode){return NDK_OK;}
int NDK_ScrInitGui(void){return NDK_OK;}
#endif
#endif

#if defined ME15C
int NDK_PortTxSendOver(EM_PORT_NUM emPort){return NDK_OK;}
int NDK_KbFlush(void){return NDK_OK;}
int NDK_BTGetPairingStatus(char * pszKey,int * pnStatus){return NDK_OK;}
int NDK_BTConfirmPairing(const char * pszKey,uint unConfirm){return NDK_OK;}
int NDK_BTEnterCommand(void){return NDK_OK;}
int NDK_BTExitCommand(void){return NDK_OK;}
int NDK_BTSetPairingMode(EM_PAIRING_MODE emMode){return NDK_OK;}
int NDK_BTSetPIN(const char * pinstr){return NDK_OK;}
int NDK_CalcLRC(const uchar * psBuf,int nLen,uchar * ucLRC){return NDK_OK;}
int NDK_BTSetType(const char * type){return NDK_OK;}
int NDK_FsGetDiskSpace(uint unWhich,ulong * pulSpace){*pulSpace = 0;return NDK_OK;}
int NDK_RfidCloseRf(void){return NDK_OK;}
int NDK_SysSetSuspendDuration(uint unSec){return NDK_OK;}
int NDK_SecGetCfg(uint * punCfgInfo){return NDK_OK;}
int NDK_SecSetCfg(uint unCfgInfo){return NDK_OK;}
int NDK_SecKeyDelete(uchar ucKeyIdx, uchar ucKeyType){return -18;}
#endif

#if defined ME15CHX||defined ME15B||defined ME66	//20170412
int NDK_PortTxSendOver(EM_PORT_NUM emPort){return NDK_OK;}
int NDK_KbFlush(void){return NDK_OK;}
int NDK_BTGetPairingStatus(char * pszKey,int * pnStatus){return NDK_OK;}
int NDK_BTConfirmPairing(const char * pszKey,uint unConfirm){return NDK_OK;}
int NDK_BTEnterCommand(void){return NDK_OK;}
int NDK_BTExitCommand(void){return NDK_OK;}
int NDK_BTSetPairingMode(EM_PAIRING_MODE emMode){return NDK_OK;}
int NDK_BTSetPIN(const char * pinstr){return NDK_OK;}
int NDK_ScrClrs(void){return NDK_OK;}
int NDK_ScrSetAttr(EM_TEXT_ATTRIBUTE emNewAttr, EM_TEXT_ATTRIBUTE *pemOldAttr){return NDK_OK;}
int NDK_ScrPrintf(const char *psFormat, ...){return NDK_OK;}
int NDK_ScrInitGui(void){return NDK_OK;}
int NDK_ScrRefresh(void){return NDK_OK;}
int NDK_LedStatus(EM_LED emStatus){return NDK_OK;}
int NDK_SysBeep(void){return NDK_OK;}
int NDK_FsExist(const char * pszName){return NDK_OK;}
int NDK_FsRead(int nHandle,char * psBuffer,uint unLength){return NDK_OK;}
int NDK_FsOpen(const char * pszName,const char * pszMode){return NDK_OK;}
int NDK_FsClose(int nHandle){return NDK_OK;}
int NDK_SysDelay(uint unDelayTime){return NDK_OK;}
int NDK_SysStartWatch(void){return NDK_OK;}
int NDK_SysStopWatch(uint * punTime){return NDK_OK;}
int NDK_FsDel(const char * pszName){return NDK_OK;}
#endif

#if defined ME15B||defined ME66
int NDK_SysSetSuspendDuration(uint unSec){return NDK_OK;}
int NDK_SetIgnoreProtocol(int nModeCode){return NDK_OK;}
int NDK_PiccQuickRequest(int nModeCode){return NDK_OK;}
#endif

#if defined ME66
int NDK_ScanDoScan(int nTimeOut,char *pszValue,int *pnLen){return NDK_OK;}
#endif

#if defined SP610
int NDK_SysSetSuspendDuration(uint unSec){return NDK_OK;}
int NDK_ScrFullRefresh(void){return NDK_OK;}
#endif

#if defined SP630PG
int NDK_BTSetDiscoverableStatus(const char status) {return NDK_OK;}
#endif

//新增K21部分不支持的NDK函数 直接返回成功
#if K21_ENABLE

#if !(CPU5810X_ENABLE||defined ME50NX||defined ME68||defined ME15CHX||defined ME15B||defined ME66)
int NDK_ScrAutoUpdate(int nNewAuto,int * pnOldAuto){return NDK_OK;}
int NDK_ScrSetViewPort(uint unX,uint unY,uint unWidth,uint unHeight){return NDK_OK;}
int NDK_ScrGetViewPort(uint * punX,uint * punY,uint * punWidth,uint * punHeight){GUI_GetLCDSize(); *punWidth = g_LCDWidth; *punHeight= g_LCDHeight; return NDK_OK;}
#if !ANDIROD_ENABLE
int NDK_ScrRefresh(void){return NDK_OK;}
#endif
int NDK_ScrSetFontType(EM_DISPFONT emType){return NDK_OK;}
#endif

#if defined ME30||defined ME30S||defined ME30THM||defined ME30MH||defined ME30GX||defined ME32||defined ME65||defined ME32GX||defined ME32THM
int NDK_NetPing(char * pszIp,uint nTimeoutMs){return NDK_OK;}
int NDK_NetGetAddr(EM_COMM_TYPE emComtype,char *pszIp, char *pszMask, char *pszGateway, char *pszDns){return NDK_OK;}
int NDK_SysSetSuspend(uint unFlag){return NDK_OK;}
#endif

#if CPU5810X_ENABLE||defined ME50NX||defined ME68||defined ME66
//#if defined SP610
//int NDK_WlInit(int nTimeout,const char * pszPinPassWord,EM_WLM_STATUS * pemStatus){ *pemStatus = WLM_STATUS_OK; return NDK_OK;}
//#endif
int NDK_WlModemClose(void){return NDK_OK;}
int NDK_SysSetSuspend(uint unFlag){return NDK_OK;}
int NDK_PppGetAddr(ulong * pulLocalAddr,ulong * pulHostAddr){return NDK_OK;}
int NDK_ScanInit(void){return NDK_OK;}
int NDK_ScanSet(EM_SCAN_SETTYPE emScanSet,uint unSetValue){return NDK_OK;}
#endif
#if defined ME50||defined ME62||defined SP610||defined ME50NX||defined ME68  //开发说ME50C ME50H ME50N均有编译此函数故不再定义避免编译重定义 20180515 modify
int NDK_NetPing(char * pszIp,uint nTimeoutMs)
{	
	cls_show_msg("不支持Ping");
	return NDK_ERR;
}
#endif

#if ANDIROD_ENABLE ||defined ME30S//defined N900||
int NDK_FsGetDiskSpace(uint unWhich,ulong * pulSpace){*pulSpace = 0;return NDK_OK;}
int NDK_FsClearAppFile(void){return NDK_OK;}
#endif

#if defined ME30S
int NDK_FsDir(const char *psPath,  char * psBuf, uint *punNum){return NDK_OK;}
#endif

#endif

//中端产品先支持 802.1x认证模式
#if !K21_ENABLE//!(defined SP60||defined SP50||defined SP80||defined ME31S)//那个产品的libndk.so支持这个函数，就可以在这里增加条件编译后进行测试
int NDK_WiFiConnect_8021x(const char *pszESSIDName, const ST_WIFI_8021x_PARAM *pstParam){return -18;}
#endif
//JNI调用NDK接口 故不再使用adb从串口输出 把相关串口操作关闭 20170726 jym
#if 0//ANDIROD_ENABLE	//在安卓端通过MPOS命令集操作K21端测试的设备需要自定义一套对安卓和K21间通讯的串口函数
static int fdIPC= -1;		//应用层MPOS命令的读写接口描述符

/**********************************************************************
* 函数名称： set_com_config
* 功能描述： 设置串口参数等
* 接口描述
*   输入参数：  int fd - 串口对应文件描述符
*		  					int baud_rate - 波特率
*		  					int data_bits - 数据长
*		  					char parity    - 校验位 N或n或S或s=无校验 E或e=偶校验 O或o=奇校验
*		  					int stop_bits - 停止位
*		  					char ir_en	  - 红外通讯防止反射串扰,即自发自收防护功能 I或i或Y或y=开启 , N或n=关闭
*		  					char block_en - 是否开启读写阻塞  B或b或Y或y=阻塞 N或n=非阻塞

*   返回参数： int  - 			0 表示成功, 非0失败,-1=fd错 -2=设置串口参数出错 -3=设置阻塞失败

*   影响的参数：

* 补充说明 :
***********************************************************************/
int setComConfig(int fd,int baud_rate, int data_bits, char parity, int stop_bits,char ir_en,char block_en)
{
	struct termios new_cfg,old_cfg;
	int speed,flag;

	/*保存测试现有串口参数设置，在这里如果串口号等出错，会有相关的出错信息*/
	if  (tcgetattr(fd, &old_cfg)  !=  0)
	{
		return -1;
	}

	/*设置字符大小*/
	new_cfg = old_cfg;
	cfmakeraw(&new_cfg);
	new_cfg.c_cflag &= ~CSIZE;

  	/*设置波特率*/
  	switch (baud_rate)
  	{
  		case 2400:
			speed = B2400;
			break;
  		case 4800:
			speed = B4800;
			break;
  		case 9600:
			speed = B9600;
			break;
		case 19200:
			speed = B19200;
			break;
  		case 38400:
			speed = B38400;
			break;
  		case 57600:
			speed = B57600;
			break;
  		case 230400:
			speed = B230400;
			break;
		default:
		case 115200:
			speed = B115200;
			break;
  	}
	flag = cfsetispeed(&new_cfg, speed);
	flag = cfsetospeed(&new_cfg, speed);

	/*设置数据位*/
	switch (data_bits)
	{
		case 7:
			new_cfg.c_cflag |= CS7;
			break;
		default:
		case 8:
			new_cfg.c_cflag |= CS8;
			break;
  	}

  	/*设置奇偶校验位*/
  	switch (parity)
  	{
		default:
		case 'n':
		case 'N':
		{
			new_cfg.c_cflag &= ~PARENB;
			new_cfg.c_iflag &= ~INPCK;
		}
		break;

        case 'o':
		case 'O':
        {
            new_cfg.c_cflag |= (PARODD | PARENB);
            new_cfg.c_iflag |= INPCK;
        }
        break;

		case 'e':
        case 'E':
		{
			new_cfg.c_cflag |= PARENB;
			new_cfg.c_cflag &= ~PARODD;
			new_cfg.c_iflag |= INPCK;
        }
		break;

        case 's':  /*as no parity*/
		case 'S':
        {
			new_cfg.c_cflag &= ~PARENB;
			new_cfg.c_cflag &= ~CSTOPB;
		}
		break;
	}

	/*设置停止位*/
	switch (stop_bits)
	{
		default:
		case 1:
			new_cfg.c_cflag &=  ~CSTOPB;
			break;
		case 2:
			new_cfg.c_cflag |= CSTOPB;
			break;
	}

	/*设置等待时间和最小接收字符*/
	new_cfg.c_cc[VTIME]  = 0;
	new_cfg.c_cc[VMIN] = 1;

	/* 设置红外自发自收防护功能 @@@2011/09/16 */
  	switch (ir_en)
  	{
  		// 红外自发自收防护功能开启
  		case 'Y':
   		case 'y':
 		case 'I':
 		case 'i':
  			new_cfg.c_iflag |= IMAXBEL;
  			break;

  	  	// 红外自发自收防护功能关闭
 		default:
  		case 'N':
   		case 'n':
  			new_cfg.c_iflag &= ~IMAXBEL;
  			break;

  	}

	/*处理未接收字符*/
	tcflush(fd, TCIFLUSH);

	/*激活新配置*/
	if((tcsetattr(fd, TCSANOW, &new_cfg)) != 0)
	{
		perror("tcsetattr");
		return -2;
	}

	/*处理阻塞状态设置*/
	flag = fcntl(fd,F_GETFL,0);
	if((block_en == 'Y')||(block_en == 'y')||(block_en == 'B')||(block_en == 'b'))
	{
		// 设置串口为阻塞状态
		flag &= ~O_NONBLOCK;
	}
	else
	{ 	// 设置串口为非阻塞状态
		flag |= O_NONBLOCK;
	}
	if (fcntl(fd, F_SETFL, flag) < 0)	// (fcntl(fd, F_SETFL, 0) < 0)
	{
		return -3;
	}

	return 0;
}


int NDK_AZPortOpen(EM_PORT_NUM emPort, const char *pszAttr)
{
	fdIPC = open("/dev/ttyGS0", O_RDWR | O_NOCTTY | O_NONBLOCK);
	if (-1 == fdIPC )
	{
		return NDK_ERR;
	}

	// TODO 这里假定是串口/usb口,所以要设置波特率,今后可能是localsocket就无需了
	setComConfig(fdIPC,115200,8,'N',1,'N','N');
	
	return NDK_OK;
}

int NDK_AZPortRead(EM_PORT_NUM emPort, uint unLen, char *pszOutbuf,int nTimeoutMs, int *pnReadlen)
{
	int i, iPackLen ,iTime;
	int ji_cnt;

	ji_cnt = 0;
	iTime = 1;
	do
	{
		iPackLen = (unLen < 2048)? unLen:2048 ;
		i = read((int)fdIPC, pszOutbuf, iPackLen); 

		if((i > 0))
		{
			ji_cnt +=i;
			pszOutbuf += i;
			unLen -= i;
		}
		else
		{
			if(nTimeoutMs <= 0)
				break;
			usleep(1000);
			iTime+=1;
			
			if( (++iTime) > (int)nTimeoutMs)
				break;
		}
	}while(( unLen > 0));

	*pnReadlen = ji_cnt;
	return NDK_OK;
}

int NDK_AZPortWrite(EM_PORT_NUM emPort, uint unLen,const char *pszInbuf)
{
	return write(fdIPC, pszInbuf, unLen);
	return NDK_OK;
}

int NDK_AZPortClose(EM_PORT_NUM emPort)
{
	if (fdIPC >= 0)
	{
		close(fdIPC);
		fdIPC = -1;
	}
	return NDK_OK;
}

#endif

#if !(defined ME15C||defined ME15CHX||defined ME20||defined ME15B||defined ME66)	//ME15C为节省应用空间不编译不用的函数
static void AdjustMBoxPara(char *cCharMax, int *iLeft, int *iTop)
{
#if 0	//弃用
	/*private & local definition*/

	/*process body*/
	//cCharMax一般定为LCDCOL-3合适
	//cCharMax = LCDCOL-3;
	//cCharMax = (LCDCOL-3)*8/6;//20100401 适应由DispString(16*8点阵)改为DispString12(12*6点阵)
#if (g_cMachineModal==690)	//if (g_cMachineModal==690)
	{
		*cCharMax = 21;
		*iLeft = 10;
		*iTop = 5;
	}
#elif (g_cMachineModal==8200||g_cMachineModal==730)	//else if (g_cMachineModal==8200)
	{
		*cCharMax = 14;//zhangnw:13->14
		*iLeft = 5;
		*iTop = 3;
	}
#elif (g_cMachineModal==80)	//else if (g_cMachineModal==80)//zhangnw20060801 add
	{
		*cCharMax = 27;
		*iLeft = 10;
		*iTop = 5;
	}
#elif (g_cMachineModal==8201)	//zhangnw20100930 add
	{
		*cCharMax = 15;
		*iLeft = 5;
		*iTop = 3;
	}
#elif (g_cMachineModal==731)	//zhangnw20110221add
	{
		*cCharMax = 27;
		*iLeft = 10;
		*iTop = 5;
	}
#elif (g_cMachineModal==829)	//zhangnw201105add
	{
		*cCharMax = 12;
		*iLeft = 5;
		*iTop = 3;
	}

	return;
#endif
#else
	/*private & local definition*/
	uint FontWidth = 0, FontHeight = 0;//注意:Font是汉字而不是英文!

	/*process body*/
	//cCharMax一般定为LCDCOL-3合适
	//cCharMax = LCDCOL-3;
	//cCharMax = (LCDCOL-3)*8/6;//20100401 适应由DispString(16*8点阵)改为DispString12(12*6点阵)
	NDK_ScrGetFontSize(&FontWidth, &FontHeight);
	
	*cCharMax = g_LCDWidth/FontWidth*2-3;
	if(*cCharMax<=18)//18=128/6-3
	{
		*iLeft = 5;
		*iTop = 3;		
	}
	else
	{
		*iLeft = 10;
		*iTop = 5;	
	}

	return;
#endif
}
#endif
/****************************************************************
* function name 	 	: ShowMessageBox
* functional description 	: 弹出显示对话框
* input parameter		: pMsg----提示信息
*      				  cStyle----(BTN_OK(确认), BTN_CANCEL(取消), NULL)
*      				  iWaitTime----cStyle为NULL时延时时间, 若iWaitTime<=0, 则一直显示提示框不恢复原屏
* output parameter	 	: 
* return value			: BTN_OK-------选择了"确定"
*   	  				  BTN_CANCEL---选择了"取消"
*   	  				  失败--相应错误码  
* history 		 		: author		date			remarks
*			 		 zhangnw	 20060318      from function.c(TCR上层程序)并做适当修改、调整
*****************************************************************/
#if !ANDIROD_ENABLE
int ShowMessageBox(char* pMsg, char cStyle, int iWaitTime)
{
#if !SCR_DISABLE
	/*private & local definition*/
	int y, i, j, k, iLeft, iTop, iBottom, iRight;
	int cKey; 
	char cCharMax, cSelect;
	char cLine[20][56];//换算时取最大值,往大了考虑//char cLine[LCDROW/2][LCDCOL+16];
	char cTmp[56];//char cTmp[LCDCOL+16];
	uint FontWidth = 0, FontHeight = 0;
	uint ViewWidth = 0, ViewHeight = 0;
	
	/*process body*/
	//状态栏打开情况下需要获取屏幕实际视口大小作为看边界测试值,状态栏未打开情况下就是液晶的宽和高
	NDK_ScrGetViewPort(NULL, NULL, &ViewWidth, &ViewHeight);
	AdjustMBoxPara(&cCharMax, &iLeft, &iTop);
	NDK_ScrGetFontSize(&FontWidth, &FontHeight);
	iBottom = ViewHeight-iTop;//iBottom = LCDROW*8-iTop;
	iRight = ViewWidth-iLeft;//iRight = LCDCOL*8-iLeft;
	if (iWaitTime >= 0)
		NDK_ScrPush();//pushscreen();

	//rectangle(iLeft, iTop, iRight, iBottom, 1, 0);
	NDK_ScrClrs();//clrscr();
	/*画窗口*/
	NDK_ScrRectangle(iLeft, iTop, iRight, iBottom, RECT_PATTERNS_NO_FILL , 0);//rectangle(iLeft, iTop, iRight, iBottom, NO_FILL, BLACK);
	NDK_ScrLine(iLeft+2, iBottom+1, iRight+1, iBottom+1, 0);//line(iLeft+2, iBottom+1, iRight+1, iBottom+1, BLACK);
	NDK_ScrLine(iRight+1, iTop+2, iRight+1, iBottom+1, 0);//line(iRight+1, iTop+2, iRight+1, iBottom+1, BLACK);

	/*将pMsg按\n划分到cLine中*/
	i = 0; k = 0; y = 0; j = 0;
	memset(cLine, 0, sizeof(cLine));
	for (i = 0; i<strlen(pMsg); i++)
	{
		if (pMsg[i]=='\n')
		{
			if (i==k)
				sprintf(cLine[j++], "%s", " ");
			else
				memcpy(cLine[j++], pMsg+k, i-k);

			k = i+1;
		}
	}
	if (pMsg[i]!='\n')
		memcpy(cLine[j++], pMsg+k, i-k);

	/*显示cLine*/
	y = 0;
	for (i = 0; i<j; i++)
	{
		for (k = 0; k<(strlen(cLine[i])+cCharMax-1)/cCharMax; k++)
		{
			memset(cTmp, 0, sizeof(cTmp));
			memcpy(cTmp, cLine[i]+k * cCharMax, cCharMax);
#if defined ME30GX||defined ME32GX
			NDK_ScrDispString(iLeft+1+abs(cCharMax-strlen(cTmp))/2*FontWidth/2, iTop+3+y*FontHeight, cTmp, 0);//DispString(iLeft+1+fabs(cCharMax-strlen(cTmp))/2 * 8, iTop+3+y * 16, cTmp); //居中显示
#else
			NDK_ScrDispString(iLeft+1+fabs(cCharMax-strlen(cTmp))/2*FontWidth/2, iTop+3+y*FontHeight, cTmp, 0);//DispString(iLeft+1+fabs(cCharMax-strlen(cTmp))/2 * 8, iTop+3+y * 16, cTmp); //居中显示
			//非所有机器均支持DispString12(iLeft+1+fabs(cCharMax-strlen(cTmp))/2 *6, iTop+3+y * 12, cTmp);//zhangnw20100401modify for more information
#endif
			y++;
		}
	}

	cKey = 0;
	cSelect = BTN_OK;
	while (1)
	{
		if (BTN_OK & cStyle)
			GUI_DispStringEx(iRight-FontWidth*2-1, iBottom-FontWidth-1, "确定", cSelect==BTN_OK?TEXT_ATTRIBUTE_REVERSE:TEXT_ATTRIBUTE_NORMAL/*REVERSE_TEXT:NORMAL_TEXT*/);
		if (BTN_CANCEL & cStyle)
			GUI_DispStringEx(iLeft+1, iBottom-FontWidth-1, "取消", cSelect==BTN_CANCEL?TEXT_ATTRIBUTE_REVERSE:TEXT_ATTRIBUTE_NORMAL/*REVERSE_TEXT:NORMAL_TEXT*/);
		if (cStyle!=0/*NULL*/)
		{
INPUT:
			cKey = lib_getkeycode((iWaitTime+999)/1000);//cKey = getkeycode((iWaitTime+999)/1000);
			switch (cKey)
			{
			case ENTER :
				return cSelect;
				break;
			case ESC:
				if (cStyle & BTN_CANCEL)
					return BTN_CANCEL;
				else
					goto INPUT;

				break;
			case LEFT:
			case RIGHT:
				if ((BTN_CANCEL & cStyle) && (BTN_OK & cStyle))
					cSelect = (cSelect==BTN_CANCEL)?BTN_OK:BTN_CANCEL;
				break;
			case 0:
				return(cSelect);
				break;
			default:
				goto INPUT;
				break;
			}
		}
		else
		{
			if (iWaitTime>0)
			{
				for (i = 0; i<iWaitTime/20; i++)
				{
					NDK_SysMsDelay(20);//msdelay(20);
					if (lib_kbhit()==ESC);//if (kbhit()==ESC)
					{
						NDK_ScrPop();//popscreen();
						return NDK_ERR_QUIT;//(QUIT);
					}
				}
			}
			else//iWaitTime<0, 一直显示, 不恢复原屏幕
				return(SUCC);

			break;
		}
	}
	//popscreen();

	NDK_ScrRefresh();
	return cKey;
#else
	/*private & local definition*/
	int nKeyin = 0;

	/*process body*/
#if 0//ANDIROD_ENABLE
	NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");	
	NDK_AZPortWrite(g_com, strlen(pMsg), pMsg);
	NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
	if(BTN_OK&cStyle)
		NDK_AZPortWrite(g_com, strlen("确认:是\r\n"), "确认:是\r\n");
	if(BTN_CANCEL&cStyle)
		NDK_AZPortWrite(g_com, strlen("取消:否\r\n"), "取消:否\r\n");
#else
	NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");//portwrite(g_com, strlen("\r\n"), "\r\n");	
	NDK_PortWrite(g_com, strlen(pMsg), pMsg);//portwrite(g_com, strlen(pMsg), pMsg);
	NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");//portwrite(g_com, strlen("\r\n"), "\r\n");
	if(BTN_OK&cStyle)
		NDK_PortWrite(g_com, strlen("确认:是\r\n"), "确认:是\r\n");//portwrite(g_com, strlen("确认:是\r\n"), "确认:是\r\n");
	if(BTN_CANCEL&cStyle)
		NDK_PortWrite(g_com, strlen("取消:否\r\n"), "取消:否\r\n");//portwrite(g_com, strlen("取消:否\r\n"), "取消:否\r\n");
#endif

	while(1)
	{
		nKeyin = wait_anykey(iWaitTime);
		if(((cStyle&BTN_OK)==BTN_OK && nKeyin==ENTER) || nKeyin==0)//无键盘设备超时时nKeyin==0也允许自动运行,避免自动测试完成时死循环无法重启
			return BTN_OK;
		if((cStyle&BTN_CANCEL)==BTN_CANCEL && nKeyin==ESC)
			return BTN_CANCEL;
		if(cStyle==0/*NULL*/)
			return nKeyin;
	}
#endif
}
#endif

/****************************************************************
* function name 	 	: GUI_DispStringEx
* functional description 	: 指定位置显示文字
* input parameter		: x, y---------坐标
*   					  Msg----------提示信息
*   					  TextAttr-----文字属性
* output parameter	 	: 
* return value			: 
* history 		 		: author		date			remarks
*			 		 zhangnw	 20060318      from function.c(TCR上层程序)并做适当修改、调整
*****************************************************************/
#if !SCR_DISABLE
void GUI_DispStringEx(int x, int y, char* pMsg, EM_TEXT_ATTRIBUTE iTextAttr)
{
	/*private & local definition*/	
	EM_TEXT_ATTRIBUTE iOldAttr = 0;

	/*process body*/
	NDK_ScrSetAttr(iTextAttr, &iOldAttr);//iOldAttr = settextattr(iTextAttr);
	NDK_ScrDispString(x, y, pMsg, 0);//DispString(x, y, pMsg);
	NDK_ScrSetAttr(iOldAttr, NULL);//settextattr(iOldAttr);
	NDK_ScrRefresh();
}
#endif

#if !(defined ME15C||defined ME15CHX||defined ME20||defined ME15B||defined ME66)	//ME15C为节省应用空间不编译不用的函数
static void Is_testresult_exist(struct tm sttPosTime)
{
	char BoardVer[32] = {0}, BIOSVer[128] = {0}, machine[32] = {0},szBuf[MAXDISPBUFSIZE+1024]={0};
	uint len= 0;
	int fd = 0;
	
	if(NDK_FsExist(LOGFILE)!=NDK_OK)//报告文件不存在则创建文件,并写入文件头
	{
		if(NDK_OK!=NDK_SysGetPosInfo(SYS_HWINFO_GET_POS_TYPE, &len, machine))		
			strcpy(machine, "UNKNOWN");

		if(NDK_OK!=NDK_SysGetPosInfo(SYS_HWINFO_GET_BIOS_VER, &len, BIOSVer))		
			strcpy(BIOSVer, "UNKNOWN");
			
		if(NDK_OK!=NDK_SysGetPosInfo(SYS_HWINFO_GET_BOARD_VER, &len, BoardVer))		
			strcpy(BoardVer, "UNKNOWN");
			
		sprintf(szBuf, REPORTHEAD, sttPosTime.tm_wday, sttPosTime.tm_mon+1, sttPosTime.tm_mday,sttPosTime.tm_hour, 
			sttPosTime.tm_min,sttPosTime.tm_sec, sttPosTime.tm_year+1900, machine, BIOSVer, BoardVer);
			
		if((fd = NDK_FsOpen(LOGFILE,"w"))<0)
		{
			cls_show_msg("%s, line %d: 打开文件失败,请查看文件系统是否异常", __FILE__, __LINE__);
			return;
		}
		else
		{
			if(NDK_FsWrite(fd, szBuf, strlen(szBuf))!=strlen(szBuf))
			{
				cls_show_msg("%s, line %d: 写入文件失败...", __FILE__, __LINE__);
			}
		}
		NDK_FsClose(fd);
	}
	return;
}
#endif

#if !ANDIROD_ENABLE  //通过jni调用NDK接口方案，此处几个函数都使用安卓层的封装函数
int cls_printf(const char* msg, ...)
{
	/*private & local definition*/
	int cnt = 0;
	va_list args;
	char tips[MAXDISPBUFSIZE] = {0};
	char * p_tips = tips;

	/*process body*/
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
	NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
	NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif
	NDK_ScrClrs();
	va_start(args, msg);
#if SPRINTF_UNSPORT
	cnt = t_print(&p_tips, msg, args);
#else
	cnt = vsprintf(p_tips, msg, args);
	va_end(args);
#endif 

	if (cnt>sizeof(tips)-1)
	{
		cls_show_msg("%s, line %d: 信息太长,任意键退出...", __FILE__, __LINE__);
		NDK_SysReboot();
		return (-1);//表示发生了ERROR
	}
	else
	{
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
		NDK_AZPortWrite(g_com, strlen(tips), tips);
		NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
		NDK_PortWrite(g_com, strlen(tips), tips);
		NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif
		cnt = NDK_ScrPrintf("%s", tips);
		NDK_ScrRefresh();
		return cnt;
	}
}

int cls_show_msg1_record(char* filename, char* funname,int time, const char* msg, ...)
{
	/*private & local definition*/
	int cnt = 0;
#if !K21_ENABLE||CPU5810X_ENABLE||defined ME50NX||defined ME68
	int fd = 0;
#endif
	va_list args;
	char tips[MAXDISPBUFSIZE] = {0};
	char * p_tips = tips;
#if !(defined ME15CHX||defined ME15B||defined ME66)//ME15C不支文件系统为节省代码空间进行条件编译 20170213 linwl
	struct tm sttPosTime;
	char timebuf[128] = {0}, sBuffer[MAXDISPBUFSIZE+512] = {0};
#endif	
	
	/*process body*/
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
	NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
	NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif
	NDK_ScrClrs();//clrscr();
	va_start(args, msg);
#if SPRINTF_UNSPORT
	cnt = t_print(&p_tips, msg, args);
#else
	cnt = vsprintf(p_tips, msg, args);
	va_end(args);
#endif 

	if (cnt>sizeof(tips)-1)
	{
		cls_show_msg1(5,"%s, line %d: 信息太长,任意键退出(重启)...", __FILE__, __LINE__);
		NDK_SysReboot();//nlexit(-1);
	}
	else
	{
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
		NDK_AZPortWrite(g_com, strlen(tips), tips);
		NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
		NDK_PortWrite(g_com, strlen(tips), tips);
		NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif
#if !SCR_DISABLE
		NDK_ScrPrintf("%s", tips);
		NDK_ScrRefresh();
#endif
	}

#if !(defined ME15CHX||defined ME15B||defined ME66)//ME15C为节省代码空间进行条件编译 20170213 linwl
	//构造结果数据
	if(NDK_SysGetPosTime(&sttPosTime)==NDK_OK)
	{	
		sprintf(timebuf, "\n%04d/%02d/%02d %02d:%02d:%02d", sttPosTime.tm_year+1900,sttPosTime.tm_mon+1,\
				sttPosTime.tm_mday,sttPosTime.tm_hour,sttPosTime.tm_min,sttPosTime.tm_sec);
	}
	sprintf(sBuffer,"%s 文件名:%s 函数名:%s %s",timebuf,filename,funname,tips);

	//平台自动测试写串口报告
	if(auto_flag==1)//autotest_flag
	{
#if 0//ANDIROD_ENABLE
		NDK_AZPortWrite(g_com, strlen(sBuffer), sBuffer);
#else
		NDK_PortWrite(g_com, strlen(sBuffer), sBuffer);//portwrite(g_com, strlen(tips), tips);
#endif
		//return wait_anykey(time);
	}
#endif

#if !K21_ENABLE||CPU5810X_ENABLE||defined ME50NX||defined ME68
	//写文件系统报告
	Is_testresult_exist(sttPosTime); //检测文件是否存在，如不存在写入文件头
	if((fd = NDK_FsOpen(LOGFILE,"w"))<0)
	{
		cls_show_msg1(5,"%s, line %d: 打开文件失败,请查看文件系统是否异常", __FILE__, __LINE__);
		goto END;
	}
	else
	{
		if(NDK_FsSeek(fd, 0, SEEK_END)!=NDK_OK)
		{
			cls_show_msg1(5,"%s, line %d: 定位文件失败...", __FILE__, __LINE__);
			goto END;
		}
		if(NDK_FsWrite(fd, sBuffer, strlen(sBuffer))!=strlen(sBuffer))
		{
			cls_show_msg1(5,"%s, line %d: 写入文件失败...", __FILE__, __LINE__);
			goto END;
		}
	}

END:	
	NDK_FsClose(fd);
#endif

	return wait_anykey(time);
}

int cls_show_msg_record(char* filename, char* funname,const char* msg, ...)
{
	/*private & local definition*/
	int cnt = 0;
#if !K21_ENABLE||CPU5810X_ENABLE||defined ME50NX||defined ME68
	int fd = 0;
#endif
	va_list args;
	char tips[MAXDISPBUFSIZE] = {0};
	char * p_tips = tips;
#if !(defined ME15CHX||defined ME15B||defined ME66)//ME15C不支文件系统为节省代码空间进行条件编译 20170213 linwl
	struct tm sttPosTime;
	char timebuf[128] = {0}, sBuffer[MAXDISPBUFSIZE+512] = {0};
#endif	

	/*process body*/
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
	NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
	NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif
	NDK_ScrClrs();
	va_start(args, msg);
#if SPRINTF_UNSPORT
	cnt = t_print(&p_tips, msg, args);
#else
	cnt = vsprintf(p_tips, msg, args);
	va_end(args);
#endif 

	if (cnt>sizeof(tips)-1)
	{
		cls_show_msg("%s, line %d: 信息太长,任意键退出(重启)...", __FILE__, __LINE__);
		NDK_SysReboot();//nlexit(-1);
	}
	else
	{
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
		NDK_AZPortWrite(g_com, strlen(tips), tips);
		NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
		NDK_PortWrite(g_com, strlen(tips), tips);
		NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif
#if !SCR_DISABLE
		NDK_ScrPrintf("%s", tips);
		NDK_ScrRefresh();
#endif
	}
	
#if !(defined ME15CHX||defined ME15B||defined ME66)//ME15C不支文件系统为节省代码空间进行条件编译 20170213 linwl	
	//构造结果数据
	if(NDK_SysGetPosTime(&sttPosTime)==NDK_OK)
	{	
		sprintf(timebuf, "\n%04d/%02d/%02d %02d:%02d:%02d", sttPosTime.tm_year+1900,sttPosTime.tm_mon+1,\
				sttPosTime.tm_mday,sttPosTime.tm_hour,sttPosTime.tm_min,sttPosTime.tm_sec);
	}
	sprintf(sBuffer,"%s 文件名:%s 函数名:%s %s",timebuf,filename,funname,tips);

	//平台自动测试写串口报告
	if(auto_flag==1)//autotest_flag
	{
#if 0//ANDIROD_ENABLE
		NDK_AZPortWrite(g_com, strlen(sBuffer), sBuffer);
#else
		NDK_PortWrite(g_com, strlen(sBuffer), sBuffer);
#endif
		//return wait_anykey(5);
	}
#endif

#if !K21_ENABLE||CPU5810X_ENABLE||defined ME50NX||defined ME68
	//写入报告文件
	Is_testresult_exist(sttPosTime); //检测文件是否存在，如不存在写入文件头
	if((fd = NDK_FsOpen(LOGFILE,"w"))<0)
	{
		cls_show_msg1(5,"%s, line %d: 打开文件失败,请查看文件系统是否异常", __FILE__, __LINE__);
		goto END;
	}
	else
	{
		if(NDK_FsSeek(fd, 0, SEEK_END)!=NDK_OK)
		{
			cls_show_msg1(5,"%s, line %d: 定位文件失败...", __FILE__, __LINE__);
			goto END;
		}		
		if(NDK_FsWrite(fd, sBuffer, strlen(sBuffer))!=strlen(sBuffer))
		{
			cls_show_msg1(5,"%s, line %d:写入文件失败...", __FILE__, __LINE__);
			goto END;
		}
	}
		
END:
	NDK_FsClose(fd);
#endif

	if(auto_flag==1||g_SequencePressFlag==1)
		return wait_anykey(3);  //return wait_anykey(0); 要进行多个压力连续进行，防止送结果后就被停住
	else
		return wait_anykey(0);
}

int cls_show_msg1(int time, const char* msg, ...)
{
	/*private & local definition*/
	int cnt = 0;
	va_list args;
	char tips[MAXDISPBUFSIZE] = {0};
	char * p_tips = tips;
		
	/*process body*/
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
	NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
	NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif
	NDK_ScrClrs();

	va_start(args, msg);
#if SPRINTF_UNSPORT
	cnt = t_print(&p_tips, msg, args);
#else
	cnt = vsprintf(p_tips, msg, args);
	va_end(args);
#endif 

	if (cnt>sizeof(tips)-1)
	{
		cls_show_msg("%s, line %d: 信息太长,任意键退出(重启)...", __FILE__, __LINE__);
		NDK_SysReboot();
	}
	else
	{
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
		NDK_AZPortWrite(g_com, strlen(tips), tips);
		NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
		NDK_PortWrite(g_com, strlen(tips), tips);
		NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif
#if !SCR_DISABLE
		NDK_ScrPrintf("%s", tips);
		NDK_ScrRefresh();
#endif
	}

#if defined ME11||defined ME15||defined ME15C||defined ME15CHX||defined ME20||defined ME15B||defined ME66//11,15不支持RTC硬时钟不能使用wait_anykey(time);   20141030 linwl
	sleep(2);
	return lib_getkeycode(time);
#else
	return wait_anykey(time);
#endif
}

int cls_show_msg(const char* msg, ...)
{
	/*private & local definition*/
	int cnt = 0;
	va_list args;
	char tips[MAXDISPBUFSIZE] = {0};
	char * p_tips = tips;
	
	/*process body*/
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
	NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
	NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif	
	NDK_ScrClrs();
	va_start(args, msg);
#if SPRINTF_UNSPORT
	cnt = t_print(&p_tips, msg, args);
#else
	cnt = vsprintf(p_tips, msg, args);
	va_end(args);
#endif 

	if (cnt>sizeof(tips)-1)
	{
		cls_show_msg("%s, line %d: 信息太长,任意键退出(重启)...", __FILE__, __LINE__);
		NDK_SysReboot();
	}
	else
	{
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
		NDK_AZPortWrite(g_com, strlen(tips), tips);
		NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
		NDK_PortWrite(g_com, strlen(tips), tips);
		NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif
#if !SCR_DISABLE
		NDK_ScrPrintf("%s", tips);
		NDK_ScrRefresh();
#endif
	}
	
	return wait_anykey(0);
}
#endif

int show_msg1(int time, const char* msg, ...)
{
	/*private & local definition*/
	int cnt = 0;
	va_list args;
	char tips[MAXDISPBUFSIZE] = {0};
	char * p_tips = tips;

	/*process body*/
	va_start(args, msg);
#if SPRINTF_UNSPORT
	cnt = t_print(&p_tips, msg, args);
#else
	cnt = vsprintf(p_tips, msg, args);
	va_end(args);
#endif 

	if (cnt>sizeof(tips)-1)
	{
		cls_show_msg("%s, line %d: 信息太长,任意键退出(重启)...", __FILE__, __LINE__);
		NDK_SysReboot();
	}
	else
	{
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
		NDK_AZPortWrite(g_com, strlen(tips), tips);
		NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
		NDK_PortWrite(g_com, strlen(tips), tips);
		NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif
#if !SCR_DISABLE
		NDK_ScrPrintf("%s", tips);
		NDK_ScrRefresh();
#endif		
	}

#if defined ME11||defined ME15||defined ME15C||defined ME15CHX||defined ME20||defined ME15B||defined ME66//11,15不支持RTC硬时钟不能使用wait_anykey(time);   20141030 linwl
	sleep(2);
	return lib_getkeycode(time);
#else
	return wait_anykey(time);
#endif
}

int show_msg(const char* msg, ...)
{
	/*private & local definition*/
	int cnt = 0;
	va_list args;
	char tips[MAXDISPBUFSIZE] = {0};
	char * p_tips = tips;

	/*process body*/
	va_start(args, msg);
#if SPRINTF_UNSPORT
	cnt = t_print(&p_tips, msg, args);
#else
	cnt = vsprintf(p_tips, msg, args);
	va_end(args);
#endif 

	if (cnt>sizeof(tips)-1)
	{
		cls_show_msg("%s, line %d: 信息太长,任意键退出(重启)...", __FILE__, __LINE__);
		NDK_SysReboot();
	}
	else
	{
#if SCR_DISABLE	//重定向到串口
#if 0//ANDIROD_ENABLE
		NDK_AZPortWrite(g_com, strlen(tips), tips);
		NDK_AZPortWrite(g_com, strlen("\r\n"), "\r\n");
#else
		NDK_PortWrite(g_com, strlen(tips), tips);
		NDK_PortWrite(g_com, strlen("\r\n"), "\r\n");
#endif
#endif
#if !SCR_DISABLE
		NDK_ScrPrintf("%s", tips);
		NDK_ScrRefresh();
#endif		
	}

	return wait_anykey(0);
}

#if !(defined ME15C||defined ME15CHX||defined ME20||defined ME15B||defined ME66)	//ME15C为节省应用空间不编译不用的函数 20170213 linwl
void show_stopwatch(int enable, time_t clk)
{
	/*private & local definition*/
	char tips[16] = {0};
	EM_TEXT_ATTRIBUTE iOldAttr = TEXT_ATTRIBUTE_NORMAL;//NORMAL_TEXT;
	uint x = 0, y= 0;
	uint ViewWidth = 0, ViewHeight = 0;

	/*process body*/
	NDK_ScrGetxy(&x,&y);
	NDK_ScrGetViewPort(NULL, NULL, &ViewWidth, &ViewHeight);
	if(enable==ENABLE)
	{
#if defined GP730CP||defined GP730TOUCH||defined GP730HNT||defined GP710TOUCH
		show_stopwatch(DISABLE, 0);//add for GP730CP
#endif
		sprintf(tips, "%4lus", clk);
	}
	else
		sprintf(tips, "     ");//5个空格

	NDK_ScrSetAttr(TEXT_ATTRIBUTE_NORMAL, &iOldAttr);//iOldAttr = settextattr(NORMAL_TEXT);
	////非所有机器均支持DispString12((LCDCOL-3)*8, (LCDROW-1)*8-4, tips);
	NDK_ScrDispString(ViewWidth-40, ViewHeight-12, tips, 1);//Disp8x8Str((LCDCOL-5)*8, (LCDROW-1)*8-4, tips);
	NDK_ScrSetAttr(iOldAttr, NULL);//settextattr(iOldAttr);
	NDK_ScrGotoxy(x,y);
	NDK_ScrRefresh();
	NDK_SysDelay(1);//加个延时可以降低对芯片压力,避免由于该函数不停的和CPU通讯引起卡机 20140505 linwl
}
#else
void show_stopwatch(int enable, time_t clk){return;}


#endif

